<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Android/src/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;  alias(libs.plugins.android.application)&#10;  // Note: set apply to true to enable google-services (requires google-services.json).&#10;  alias(libs.plugins.google.services) apply true&#10;  alias(libs.plugins.kotlin.android)&#10;  alias(libs.plugins.kotlin.compose)&#10;  alias(libs.plugins.kotlin.serialization)&#10;  alias(libs.plugins.protobuf)&#10;  alias(libs.plugins.hilt.application)&#10;  kotlin(&quot;kapt&quot;)&#10;&#10;}&#10;&#10;android {&#10;  namespace = &quot;com.google.ai.edge.gallery&quot;&#10;  compileSdk = 35&#10;&#10;  defaultConfig {&#10;    applicationId = &quot;com.google.ai.edge.gallery&quot;&#10;    minSdk = 26&#10;    targetSdk = 35&#10;    versionCode = 1&#10;    versionName = &quot;1.0.4&quot;&#10;&#10;    // Needed for HuggingFace auth workflows.&#10;    manifestPlaceholders[&quot;appAuthRedirectScheme&quot;] = &quot;com.google.ai.edge.gallery.oauth&quot;&#10;&#10;    testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;  }&#10;&#10;  buildTypes {&#10;    release {&#10;      isMinifyEnabled = false&#10;      proguardFiles(getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;), &quot;proguard-rules.pro&quot;)&#10;      signingConfig = signingConfigs.getByName(&quot;debug&quot;)&#10;    }&#10;  }&#10;  packaging {&#10;    jniLibs {&#10;      useLegacyPackaging = true&#10;    }&#10;  }&#10;  compileOptions {&#10;    sourceCompatibility = JavaVersion.VERSION_17&#10;    targetCompatibility = JavaVersion.VERSION_17&#10;  }&#10;  kotlinOptions {&#10;    jvmTarget = &quot;17&quot;&#10;    freeCompilerArgs += &quot;-Xcontext-receivers&quot;&#10;  }&#10;  buildFeatures {&#10;    compose = true&#10;    buildConfig = true&#10;  }&#10;}&#10;&#10;dependencies {&#10;  implementation(libs.androidx.core.ktx)&#10;  implementation(libs.androidx.lifecycle.runtime.ktx)&#10;  implementation(libs.androidx.activity.compose)&#10;  implementation(platform(libs.androidx.compose.bom))&#10;  implementation(libs.androidx.ui)&#10;  implementation(libs.androidx.ui.graphics)&#10;  implementation(libs.androidx.ui.tooling.preview)&#10;  implementation(libs.androidx.material3)&#10;  implementation(libs.androidx.compose.navigation)&#10;  implementation(libs.kotlinx.serialization.json)&#10;  implementation(libs.material.icon.extended)&#10;  implementation(libs.androidx.work.runtime)&#10;  implementation(libs.androidx.datastore)&#10;  implementation(libs.com.google.code.gson)&#10;  implementation(libs.androidx.lifecycle.process)&#10;  implementation(libs.mediapipe.tasks.text)&#10;  implementation(libs.mediapipe.tasks.genai)&#10;  implementation(libs.mediapipe.tasks.imagegen)&#10;  implementation(libs.commonmark)&#10;  implementation(libs.richtext)&#10;  implementation(libs.tflite)&#10;  implementation(libs.tflite.gpu)&#10;  implementation(libs.tflite.support)&#10;  implementation(libs.camerax.core)&#10;  implementation(libs.camerax.camera2)&#10;  implementation(libs.camerax.lifecycle)&#10;  implementation(libs.camerax.view)&#10;  implementation(libs.openid.appauth)&#10;  implementation(libs.androidx.splashscreen)&#10;  implementation(libs.protobuf.javalite)&#10;  implementation(libs.hilt.android)&#10;  implementation(libs.hilt.navigation.compose)&#10;  implementation(platform(libs.firebase.bom))&#10;  implementation(libs.firebase.analytics)&#10;  implementation(libs.firebase.auth.ktx)&#10;  implementation(&quot;com.google.firebase:firebase-messaging:23.3.1&quot;)&#10;  implementation(&quot;com.google.firebase:firebase-messaging-ktx:23.3.1&quot;)&#10;  implementation(libs.google.identity.googleid)&#10;  kapt(libs.hilt.android.compiler)&#10;  testImplementation(libs.junit)&#10;  androidTestImplementation(libs.androidx.junit)&#10;  androidTestImplementation(libs.androidx.espresso.core)&#10;  androidTestImplementation(platform(libs.androidx.compose.bom))&#10;  androidTestImplementation(libs.androidx.ui.test.junit4)&#10;  androidTestImplementation(libs.hilt.android.testing)&#10;  debugImplementation(libs.androidx.ui.tooling)&#10;  debugImplementation(libs.androidx.ui.test.manifest)&#10;  implementation(&quot;com.google.android.gms:play-services-auth:20.7.0&quot;)&#10;  implementation(&quot;com.google.android.gms:play-services-location:21.2.0&quot;)&#10;&#10;  // TDLib dependency removed temporarily to fix build issues&#10;&#10;  // Gmail API client libraries&#10;  implementation(&quot;com.google.api-client:google-api-client-android:2.2.0&quot;)&#10;  implementation(&quot;com.google.oauth-client:google-oauth-client-jetty:1.34.1&quot;)&#10;  implementation(&quot;com.google.apis:google-api-services-gmail:v1-rev20220404-2.0.0&quot;)&#10;  implementation(&quot;javax.mail:mail:1.4.7&quot;)&#10;}&#10;&#10;protobuf {&#10;  protoc {&#10;    artifact = &quot;com.google.protobuf:protoc:4.26.1&quot;&#10;  }&#10;  plugins {&#10;    create(&quot;java&quot;) {&#10;      artifact = &quot;com.google.protobuf:protoc-gen-java:4.26.1&quot;&#10;    }&#10;  }&#10;  generateProtoTasks {&#10;    all().forEach {&#10;      it.plugins {&#10;        create(&quot;java&quot;) {&#10;          option(&quot;lite&quot;)&#10;        }&#10;      }&#10;    }&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;  alias(libs.plugins.android.application)&#10;  // Note: set apply to true to enable google-services (requires google-services.json).&#10;  alias(libs.plugins.google.services) apply true&#10;  alias(libs.plugins.kotlin.android)&#10;  alias(libs.plugins.kotlin.compose)&#10;  alias(libs.plugins.kotlin.serialization)&#10;  alias(libs.plugins.protobuf)&#10;  alias(libs.plugins.hilt.application)&#10;  kotlin(&quot;kapt&quot;)&#10;&#10;}&#10;&#10;android {&#10;  namespace = &quot;com.google.ai.edge.gallery&quot;&#10;  compileSdk = 35&#10;&#10;  defaultConfig {&#10;    applicationId = &quot;com.google.ai.edge.gallery&quot;&#10;    minSdk = 26&#10;    targetSdk = 35&#10;    versionCode = 1&#10;    versionName = &quot;1.0.4&quot;&#10;&#10;    // Needed for HuggingFace auth workflows.&#10;    manifestPlaceholders[&quot;appAuthRedirectScheme&quot;] = &quot;com.google.ai.edge.gallery.oauth&quot;&#10;&#10;    testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;  }&#10;&#10;  buildTypes {&#10;    release {&#10;      isMinifyEnabled = false&#10;      proguardFiles(getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;), &quot;proguard-rules.pro&quot;)&#10;      signingConfig = signingConfigs.getByName(&quot;debug&quot;)&#10;    }&#10;  }&#10;  packaging {&#10;    jniLibs {&#10;      useLegacyPackaging = true&#10;    }&#10;  }&#10;  compileOptions {&#10;    sourceCompatibility = JavaVersion.VERSION_17&#10;    targetCompatibility = JavaVersion.VERSION_17&#10;  }&#10;  kotlinOptions {&#10;    jvmTarget = &quot;17&quot;&#10;    freeCompilerArgs += &quot;-Xcontext-receivers&quot;&#10;  }&#10;  buildFeatures {&#10;    compose = true&#10;    buildConfig = true&#10;  }&#10;}&#10;&#10;dependencies {&#10;  implementation(libs.androidx.core.ktx)&#10;  implementation(libs.androidx.lifecycle.runtime.ktx)&#10;  implementation(libs.androidx.activity.compose)&#10;  implementation(platform(libs.androidx.compose.bom))&#10;  implementation(libs.androidx.ui)&#10;  implementation(libs.androidx.ui.graphics)&#10;  implementation(libs.androidx.ui.tooling.preview)&#10;  implementation(libs.androidx.material3)&#10;  implementation(libs.androidx.compose.navigation)&#10;  implementation(libs.kotlinx.serialization.json)&#10;  implementation(libs.material.icon.extended)&#10;  implementation(libs.androidx.work.runtime)&#10;  implementation(libs.androidx.datastore)&#10;  implementation(libs.com.google.code.gson)&#10;  implementation(libs.androidx.lifecycle.process)&#10;  implementation(libs.mediapipe.tasks.text)&#10;  implementation(libs.mediapipe.tasks.genai)&#10;  implementation(libs.mediapipe.tasks.imagegen)&#10;  implementation(libs.commonmark)&#10;  implementation(libs.richtext)&#10;  implementation(libs.tflite)&#10;  implementation(libs.tflite.gpu)&#10;  implementation(libs.tflite.support)&#10;  implementation(libs.camerax.core)&#10;  implementation(libs.camerax.camera2)&#10;  implementation(libs.camerax.lifecycle)&#10;  implementation(libs.camerax.view)&#10;  implementation(libs.openid.appauth)&#10;  implementation(libs.androidx.splashscreen)&#10;  implementation(libs.protobuf.javalite)&#10;  implementation(libs.hilt.android)&#10;  implementation(libs.hilt.navigation.compose)&#10;  implementation(platform(libs.firebase.bom))&#10;  implementation(libs.firebase.analytics)&#10;  implementation(libs.firebase.auth.ktx)&#10;  implementation(&quot;com.google.firebase:firebase-messaging:23.3.1&quot;)&#10;  implementation(&quot;com.google.firebase:firebase-messaging-ktx:23.3.1&quot;)&#10;  implementation(libs.google.identity.googleid)&#10;  kapt(libs.hilt.android.compiler)&#10;  testImplementation(libs.junit)&#10;  androidTestImplementation(libs.androidx.junit)&#10;  androidTestImplementation(libs.androidx.espresso.core)&#10;  androidTestImplementation(platform(libs.androidx.compose.bom))&#10;  androidTestImplementation(libs.androidx.ui.test.junit4)&#10;  androidTestImplementation(libs.hilt.android.testing)&#10;  debugImplementation(libs.androidx.ui.tooling)&#10;  debugImplementation(libs.androidx.ui.test.manifest)&#10;  implementation(&quot;com.google.android.gms:play-services-auth:20.7.0&quot;)&#10;  implementation(&quot;com.google.android.gms:play-services-location:21.2.0&quot;)&#10;&#10;  // TDLib dependency removed temporarily to fix build issues&#10;&#10;  // Gmail API client libraries&#10;  implementation(&quot;com.google.api-client:google-api-client-android:2.2.0&quot;)&#10;  implementation(&quot;com.google.oauth-client:google-oauth-client-jetty:1.34.1&quot;)&#10;  implementation(&quot;com.google.apis:google-api-services-gmail:v1-rev20220404-2.0.0&quot;)&#10;  implementation(&quot;javax.mail:mail:1.4.7&quot;)&#10;}&#10;&#10;protobuf {&#10;  protoc {&#10;    artifact = &quot;com.google.protobuf:protoc:3.21.7&quot;&#10;  }&#10;  // Remove plugins section since we'll use the built-in Java plugin&#10;  generateProtoTasks {&#10;    all().forEach {&#10;      it.builtins {&#10;        create(&quot;java&quot;) {&#10;          option(&quot;lite&quot;)&#10;        }&#10;      }&#10;    }&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&#10;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    package=&quot;com.google.ai.edge.gallery&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-sdk&#10;        android:minSdkVersion=&quot;26&quot;&#10;        android:compileSdkVersion =&quot;35&quot;&#10;        android:targetSdkVersion=&quot;35&quot; /&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#10;&#10;    &lt;uses-feature&#10;        android:name=&quot;android.hardware.camera&quot;&#10;        android:required=&quot;false&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;com.google.ai.edge.gallery.GalleryApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;AI Chat Bot&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.Gallery&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.SplashActivity&quot;&#10;            android:theme=&quot;@style/Theme.Gallery.Splash&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.SignInActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.SignUpActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.AuthActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot;&#10;            android:windowSoftInputMode=&quot;adjustResize&quot;&#10;            tools:ignore=&quot;DiscouragedApi,LockedOrientationActivity&quot; /&gt;&#10;&#10;        &lt;provider&#10;            android:name=&quot;androidx.core.content.FileProvider&quot;&#10;            android:authorities=&quot;${applicationId}.provider&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:grantUriPermissions=&quot;true&quot;&gt;&#10;            &lt;meta-data&#10;                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;&#10;                android:resource=&quot;@xml/file_paths&quot; /&gt;&#10;        &lt;/provider&gt;&#10;&#10;        &lt;service&#10;            android:name=&quot;androidx.work.impl.foreground.SystemForegroundService&quot;&#10;            android:foregroundServiceType=&quot;dataSync&quot;&#10;            android:exported=&quot;false&quot;&#10;            tools:node=&quot;merge&quot;&gt;&#10;        &lt;/service&gt;&#10;&#10;        &lt;!-- For Firebase Analytics. --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;com.google.android.gms.measurement.AppMeasurementReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;        &lt;service android:name=&quot;com.google.android.gms.measurement.AppMeasurementService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot; /&gt;&#10;        &lt;service&#10;            android:name=&quot;com.google.android.gms.measurement.AppMeasurementJobService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; /&gt;&#10;&#10;        &lt;!-- Geofence Broadcast Receiver --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.GeofenceBroadcastReceiver&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;true&quot; /&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&#13;&#10;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;uses-sdk&#13;&#10;        android:minSdkVersion=&quot;26&quot;&#13;&#10;        android:compileSdkVersion =&quot;35&quot;&#13;&#10;        android:targetSdkVersion=&quot;35&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot;/&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_DATA_SYNC&quot;/&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;uses-feature&#13;&#10;        android:name=&quot;android.hardware.camera&quot;&#13;&#10;        android:required=&quot;false&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:name=&quot;com.google.ai.edge.gallery.GalleryApplication&quot;&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;AI Chat Bot&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.Gallery&quot;&#13;&#10;        tools:targetApi=&quot;31&quot;&gt;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.SplashActivity&quot;&#13;&#10;            android:theme=&quot;@style/Theme.Gallery.Splash&quot;&#13;&#10;            android:exported=&quot;true&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.SignInActivity&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.SignUpActivity&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.AuthActivity&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:screenOrientation=&quot;portrait&quot;&#13;&#10;            android:windowSoftInputMode=&quot;adjustResize&quot;&#13;&#10;            tools:ignore=&quot;DiscouragedApi,LockedOrientationActivity&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;provider&#13;&#10;            android:name=&quot;androidx.core.content.FileProvider&quot;&#13;&#10;            android:authorities=&quot;${applicationId}.provider&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:grantUriPermissions=&quot;true&quot;&gt;&#13;&#10;            &lt;meta-data&#13;&#10;                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;&#13;&#10;                android:resource=&quot;@xml/file_paths&quot; /&gt;&#13;&#10;        &lt;/provider&gt;&#13;&#10;&#13;&#10;        &lt;service&#13;&#10;            android:name=&quot;androidx.work.impl.foreground.SystemForegroundService&quot;&#13;&#10;            android:foregroundServiceType=&quot;dataSync&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            tools:node=&quot;merge&quot;&gt;&#13;&#10;        &lt;/service&gt;&#13;&#10;&#13;&#10;        &lt;!-- For Firebase Analytics. --&gt;&#13;&#10;        &lt;receiver&#13;&#10;            android:name=&quot;com.google.android.gms.measurement.AppMeasurementReceiver&quot;&#13;&#10;            android:enabled=&quot;true&quot;&#13;&#10;            android:exported=&quot;false&quot; /&gt;&#13;&#10;        &lt;service android:name=&quot;com.google.android.gms.measurement.AppMeasurementService&quot;&#13;&#10;            android:enabled=&quot;true&quot;&#13;&#10;            android:exported=&quot;false&quot; /&gt;&#13;&#10;        &lt;service&#13;&#10;            android:name=&quot;com.google.android.gms.measurement.AppMeasurementJobService&quot;&#13;&#10;            android:enabled=&quot;true&quot;&#13;&#10;            android:exported=&quot;false&quot;&#13;&#10;            android:permission=&quot;android.permission.BIND_JOB_SERVICE&quot; /&gt;&#13;&#10;&#13;&#10;        &lt;!-- Geofence Broadcast Receiver --&gt;&#13;&#10;        &lt;receiver&#13;&#10;            android:name=&quot;.GeofenceBroadcastReceiver&quot;&#13;&#10;            android:enabled=&quot;true&quot;&#13;&#10;            android:exported=&quot;true&quot; /&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceBroadcastReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceBroadcastReceiver.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofencingEvent&#10;&#10;/**&#10; * Receiver for geofence transition events.&#10; * This class handles geofence transitions and triggers notifications&#10; * when a user enters a monitored geofence area.&#10; */&#10;class GeofenceBroadcastReceiver : BroadcastReceiver() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;GeofenceBroadcastRcvr&quot;&#10;        private const val CHANNEL_ID = &quot;geofence_channel&quot;&#10;        private const val NOTIFICATION_ID = 1001&#10;    }&#10;&#10;    override fun onReceive(context: Context, intent: Intent) {&#10;        val geofencingEvent = GeofencingEvent.fromIntent(intent)&#10;&#10;        if (geofencingEvent == null) {&#10;            Log.e(TAG, &quot;GeofencingEvent is null&quot;)&#10;            return&#10;        }&#10;&#10;        if (geofencingEvent.hasError()) {&#10;            val errorMessage = GeofencingEvent.getErrorCode()&#10;            Log.e(TAG, &quot;Geofencing error: $errorMessage&quot;)&#10;            return&#10;        }&#10;&#10;        // Get the transition type&#10;        val geofenceTransition = geofencingEvent.geofenceTransition&#10;&#10;        // Check if the transition type is ENTER&#10;        if (geofenceTransition == Geofence.GEOFENCE_TRANSITION_ENTER) {&#10;            // Get the geofences that were triggered&#10;            val triggeringGeofences = geofencingEvent.triggeringGeofences&#10;&#10;            // Create notification&#10;            sendNotification(context, &quot;You have entered a tracked area&quot;)&#10;&#10;            Log.i(TAG, &quot;Geofence ENTER transition detected: ${triggeringGeofences?.size ?: 0} geofences&quot;)&#10;        } else {&#10;            // Log the transition that wasn't handled&#10;            Log.i(TAG, &quot;Geofence transition not handled: $geofenceTransition&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Creates and shows a notification with the given details&#10;     */&#10;    private fun sendNotification(context: Context, contentText: String) {&#10;        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;        // Create the notification channel for Android Oreo and higher&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Geofence Notifications&quot;&#10;            val descriptionText = &quot;Notifications for geofence transitions&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;&#10;        // Create an intent to the main activity when notification is tapped&#10;        val intent = Intent(context, MainActivity::class.java)&#10;        intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Build the notification&#10;        val builder = NotificationCompat.Builder(context, CHANNEL_ID)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_map) // Using a system icon for simplicity&#10;            .setContentTitle(&quot;Geofence Alert&quot;)&#10;            .setContentText(contentText)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setContentIntent(pendingIntent)&#10;            .setAutoCancel(true)&#10;&#10;        // Show the notification&#10;        notificationManager.notify(NOTIFICATION_ID, builder.build())&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofencingEvent&#10;&#10;/**&#10; * Receiver for geofence transition events.&#10; * This class handles geofence transitions and triggers notifications&#10; * when a user enters a monitored geofence area.&#10; */&#10;class GeofenceBroadcastReceiver : BroadcastReceiver() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;GeofenceBroadcastRcvr&quot;&#10;        private const val CHANNEL_ID = &quot;geofence_channel&quot;&#10;        private const val NOTIFICATION_ID = 1001&#10;    }&#10;&#10;    override fun onReceive(context: Context, intent: Intent) {&#10;        val geofencingEvent = GeofencingEvent.fromIntent(intent)&#10;&#10;        if (geofencingEvent == null) {&#10;            Log.e(TAG, &quot;GeofencingEvent is null&quot;)&#10;            return&#10;        }&#10;&#10;        if (geofencingEvent.hasError()) {&#10;            val errorMessage = GeofencingEvent.getErrorCode()&#10;            Log.e(TAG, &quot;Geofencing error: $errorMessage&quot;)&#10;            return&#10;        }&#10;&#10;        // Get the transition type&#10;        val geofenceTransition = geofencingEvent.geofenceTransition&#10;&#10;        // Check if the transition type is ENTER&#10;        if (geofenceTransition == Geofence.GEOFENCE_TRANSITION_ENTER) {&#10;            // Get the geofences that were triggered&#10;            val triggeringGeofences = geofencingEvent.triggeringGeofences&#10;&#10;            // Get the first triggering geofence ID&#10;            val geofenceId = triggeringGeofences?.firstOrNull()?.requestId&#10;&#10;            // Update the repository with the geofence ID&#10;            if (geofenceId != null) {&#10;                GeofenceRepository.updateLastEnteredGeofence(geofenceId)&#10;                Log.d(TAG, &quot;Updated repository with geofence ID: $geofenceId&quot;)&#10;            }&#10;&#10;            // Create notification&#10;            sendNotification(context, &quot;You have entered a tracked area&quot;)&#10;&#10;            Log.i(TAG, &quot;Geofence ENTER transition detected: ${triggeringGeofences?.size ?: 0} geofences&quot;)&#10;        } else {&#10;            // Log the transition that wasn't handled&#10;            Log.i(TAG, &quot;Geofence transition not handled: $geofenceTransition&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Creates and shows a notification with the given details&#10;     */&#10;    private fun sendNotification(context: Context, contentText: String) {&#10;        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;&#10;        // Create the notification channel for Android Oreo and higher&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Geofence Notifications&quot;&#10;            val descriptionText = &quot;Notifications for geofence transitions&quot;&#10;            val importance = NotificationManager.IMPORTANCE_HIGH&#10;            val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;            }&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;&#10;        // Create an intent to the main activity when notification is tapped&#10;        val intent = Intent(context, MainActivity::class.java)&#10;        intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP&#10;&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        // Build the notification&#10;        val builder = NotificationCompat.Builder(context, CHANNEL_ID)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_map) // Using a system icon for simplicity&#10;            .setContentTitle(&quot;Geofence Alert&quot;)&#10;            .setContentText(contentText)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;            .setContentIntent(pendingIntent)&#10;            .setAutoCancel(true)&#10;&#10;        // Show the notification&#10;        notificationManager.notify(NOTIFICATION_ID, builder.build())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceLocation.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceLocation.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;/**&#10; * Data class representing a location for geofencing&#10; */&#10;data class GeofenceLocation(&#10;    val id: String,&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val radius: Float = 100f, // Default radius of 100 meters&#10;    val expirationMs: Long = -1 // Never expire by default&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceManager.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.Manifest&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.util.Log&#10;import androidx.core.app.ActivityCompat&#10;import com.google.android.gms.location.Geofence&#10;import com.google.android.gms.location.GeofencingClient&#10;import com.google.android.gms.location.GeofencingRequest&#10;import com.google.android.gms.location.LocationServices&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Manager class for handling geofence operations&#10; */&#10;@Singleton&#10;class GeofenceManager @Inject constructor(&#10;    @ApplicationContext private val context: Context&#10;) {&#10;    private val TAG = &quot;GeofenceManager&quot;&#10;    &#10;    // GeofencingClient - the main entry point for interacting with the geofencing APIs&#10;    private val geofencingClient: GeofencingClient by lazy {&#10;        LocationServices.getGeofencingClient(context)&#10;    }&#10;    &#10;    // PendingIntent used for geofence transitions&#10;    private val geofencePendingIntent: PendingIntent by lazy {&#10;        val intent = Intent(context, GeofenceBroadcastReceiver::class.java)&#10;        PendingIntent.getBroadcast(&#10;            context,&#10;            0,&#10;            intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Registers a list of geofence locations for monitoring&#10;     * &#10;     * @param locations List of GeofenceLocation objects to monitor&#10;     * @return Boolean indicating if registration was attempted (permissions are granted)&#10;     */&#10;    fun registerGeofences(locations: List&lt;GeofenceLocation&gt;): Boolean {&#10;        // Check for location permissions first&#10;        if (ActivityCompat.checkSelfPermission(&#10;                context,&#10;                Manifest.permission.ACCESS_FINE_LOCATION&#10;            ) != PackageManager.PERMISSION_GRANTED&#10;        ) {&#10;            Log.e(TAG, &quot;Missing ACCESS_FINE_LOCATION permission&quot;)&#10;            return false&#10;        }&#10;        &#10;        // If we have no locations to monitor, return early&#10;        if (locations.isEmpty()) {&#10;            Log.w(TAG, &quot;No locations provided for geofencing&quot;)&#10;            return false&#10;        }&#10;        &#10;        // Build geofence objects from the provided locations&#10;        val geofenceList = locations.map { location -&gt;&#10;            Geofence.Builder()&#10;                .setRequestId(location.id)&#10;                .setCircularRegion(&#10;                    location.latitude,&#10;                    location.longitude,&#10;                    location.radius&#10;                )&#10;                .setExpirationDuration(location.expirationMs)&#10;                .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER)&#10;                .build()&#10;        }&#10;        &#10;        // Create the geofencing request&#10;        val geofencingRequest = GeofencingRequest.Builder().apply {&#10;            // Trigger when the device enters the geofence&#10;            setInitialTrigger(GeofencingRequest.INITIAL_TRIGGER_ENTER)&#10;            addGeofences(geofenceList)&#10;        }.build()&#10;        &#10;        // Add the geofences&#10;        geofencingClient.addGeofences(geofencingRequest, geofencePendingIntent)&#10;            .addOnSuccessListener {&#10;                Log.d(TAG, &quot;Successfully added ${locations.size} geofences&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(TAG, &quot;Failed to add geofences: ${e.message}&quot;)&#10;            }&#10;        &#10;        return true&#10;    }&#10;    &#10;    /**&#10;     * Removes all active geofences&#10;     */&#10;    fun removeGeofences() {&#10;        geofencingClient.removeGeofences(geofencePendingIntent)&#10;            .addOnSuccessListener {&#10;                Log.d(TAG, &quot;Successfully removed geofences&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(TAG, &quot;Failed to remove geofences: ${e.message}&quot;)&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/GeofenceRepository.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery&#10;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;/**&#10; * Singleton repository for sharing geofencing data across components&#10; */&#10;object GeofenceRepository {&#10;    // StateFlow to hold the ID of the most recently entered geofence&#10;    private val _lastEnteredGeofenceId = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastEnteredGeofenceId: StateFlow&lt;String?&gt; = _lastEnteredGeofenceId.asStateFlow()&#10;&#10;    /**&#10;     * Updates the last entered geofence ID&#10;     *&#10;     * @param geofenceId The ID of the geofence that was entered&#10;     */&#10;    fun updateLastEnteredGeofence(geofenceId: String) {&#10;        _lastEnteredGeofenceId.value = geofenceId&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;/**&#10; * Singleton repository for sharing geofencing data across components&#10; */&#10;object GeofenceRepository {&#10;    // StateFlow to hold the ID of the most recently entered geofence&#10;    private val _lastEnteredGeofenceId = MutableStateFlow&lt;String?&gt;(null)&#10;    val lastEnteredGeofenceId: StateFlow&lt;String?&gt; = _lastEnteredGeofenceId.asStateFlow()&#10;    &#10;    // StateFlow to hold the list of user-defined geofences&#10;    private val _userGeofences = MutableStateFlow&lt;List&lt;GeofenceLocation&gt;&gt;(emptyList())&#10;    val userGeofences: StateFlow&lt;List&lt;GeofenceLocation&gt;&gt; = _userGeofences.asStateFlow()&#10;&#10;    /**&#10;     * Updates the last entered geofence ID&#10;     *&#10;     * @param geofenceId The ID of the geofence that was entered&#10;     */&#10;    fun updateLastEnteredGeofence(geofenceId: String) {&#10;        _lastEnteredGeofenceId.value = geofenceId&#10;    }&#10;    &#10;    /**&#10;     * Adds a new geofence to the user-defined list&#10;     *&#10;     * @param geofence The geofence location to add&#10;     * @return True if added successfully, false if a geofence with the same ID already exists&#10;     */&#10;    fun addGeofence(geofence: GeofenceLocation): Boolean {&#10;        val currentList = _userGeofences.value&#10;        &#10;        // Check if a geofence with this ID already exists&#10;        if (currentList.any { it.id == geofence.id }) {&#10;            return false&#10;        }&#10;        &#10;        // Add the new geofence to the list&#10;        _userGeofences.value = currentList + geofence&#10;        return true&#10;    }&#10;    &#10;    /**&#10;     * Removes a geofence from the user-defined list by ID&#10;     *&#10;     * @param geofenceId The ID of the geofence to remove&#10;     * @return True if removed successfully, false if not found&#10;     */&#10;    fun removeGeofence(geofenceId: String): Boolean {&#10;        val currentList = _userGeofences.value&#10;        val newList = currentList.filter { it.id != geofenceId }&#10;        &#10;        if (newList.size &lt; currentList.size) {&#10;            _userGeofences.value = newList&#10;            return true&#10;        }&#10;        &#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Updates all geofences at once&#10;     *&#10;     * @param geofences The new list of geofences&#10;     */&#10;    fun updateGeofences(geofences: List&lt;GeofenceLocation&gt;) {&#10;        _userGeofences.value = geofences&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/LocationPermissionHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/LocationPermissionHelper.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.Manifest&#10;import android.app.Activity&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.Settings&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.FragmentActivity&#10;&#10;/**&#10; * Helper class for managing location permissions&#10; */&#10;class LocationPermissionHelper(private val activity: FragmentActivity) {&#10;&#10;    companion object {&#10;        const val FINE_LOCATION_PERMISSION = Manifest.permission.ACCESS_FINE_LOCATION&#10;        const val BACKGROUND_LOCATION_PERMISSION = Manifest.permission.ACCESS_BACKGROUND_LOCATION&#10;    }&#10;&#10;    // Request launcher for fine location permission&#10;    private val requestFineLocationPermissionLauncher: ActivityResultLauncher&lt;String&gt; =&#10;        activity.registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { isGranted -&gt;&#10;            if (isGranted) {&#10;                // Fine location granted, now request background location if needed&#10;                requestBackgroundLocationIfNeeded()&#10;            } else {&#10;                // Permission denied, show rationale if needed&#10;                if (ActivityCompat.shouldShowRequestPermissionRationale(activity, FINE_LOCATION_PERMISSION)) {&#10;                    showPermissionRationale(&#10;                        &quot;Location Permission Required&quot;,&#10;                        &quot;This app needs location permission to notify you when you enter specific areas.&quot;,&#10;                        FINE_LOCATION_PERMISSION&#10;                    )&#10;                } else {&#10;                    // User denied with &quot;Don't ask again&quot;, send to settings&#10;                    showSettingsPrompt()&#10;                }&#10;            }&#10;        }&#10;&#10;    // Request launcher for background location permission (Android 10+)&#10;    private val requestBackgroundLocationPermissionLauncher: ActivityResultLauncher&lt;String&gt; =&#10;        activity.registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { isGranted -&gt;&#10;            if (!isGranted) {&#10;                // Permission denied, show rationale if needed&#10;                if (ActivityCompat.shouldShowRequestPermissionRationale(activity, BACKGROUND_LOCATION_PERMISSION)) {&#10;                    showPermissionRationale(&#10;                        &quot;Background Location Permission Required&quot;,&#10;                        &quot;This app needs background location permission to detect when you enter areas even when the app is not in use.&quot;,&#10;                        BACKGROUND_LOCATION_PERMISSION&#10;                    )&#10;                } else {&#10;                    // User denied with &quot;Don't ask again&quot;, send to settings&#10;                    showSettingsPrompt()&#10;                }&#10;            }&#10;        }&#10;&#10;    /**&#10;     * Starts the permission request flow for location permissions&#10;     * @return true if all permissions are already granted, false otherwise&#10;     */&#10;    fun requestLocationPermissions(): Boolean {&#10;        // Check for fine location permission first&#10;        if (!hasPermission(activity, FINE_LOCATION_PERMISSION)) {&#10;            requestFineLocationPermissionLauncher.launch(FINE_LOCATION_PERMISSION)&#10;            return false&#10;        }&#10;&#10;        // If fine location is granted, check for background location if needed&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            if (!hasPermission(activity, BACKGROUND_LOCATION_PERMISSION)) {&#10;                requestBackgroundLocationIfNeeded()&#10;                return false&#10;            }&#10;        }&#10;&#10;        // All needed permissions are already granted&#10;        return true&#10;    }&#10;&#10;    /**&#10;     * Request background location permission for Android 10+ with explanation&#10;     */&#10;    private fun requestBackgroundLocationIfNeeded() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            AlertDialog.Builder(activity)&#10;                .setTitle(&quot;Background Location Required&quot;)&#10;                .setMessage(&quot;To receive notifications when you enter tracked areas, this app needs permission to access your location in the background.&quot;)&#10;                .setPositiveButton(&quot;Grant&quot;) { _, _ -&gt;&#10;                    requestBackgroundLocationPermissionLauncher.launch(BACKGROUND_LOCATION_PERMISSION)&#10;                }&#10;                .setNegativeButton(&quot;Not Now&quot;) { dialog, _ -&gt;&#10;                    dialog.dismiss()&#10;                }&#10;                .create()&#10;                .show()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Shows a dialog explaining why the permission is needed with option to request again&#10;     */&#10;    private fun showPermissionRationale(title: String, message: String, permission: String) {&#10;        AlertDialog.Builder(activity)&#10;            .setTitle(title)&#10;            .setMessage(message)&#10;            .setPositiveButton(&quot;Grant&quot;) { _, _ -&gt;&#10;                when (permission) {&#10;                    FINE_LOCATION_PERMISSION -&gt; requestFineLocationPermissionLauncher.launch(permission)&#10;                    BACKGROUND_LOCATION_PERMISSION -&gt; requestBackgroundLocationPermissionLauncher.launch(permission)&#10;                }&#10;            }&#10;            .setNegativeButton(&quot;Not Now&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;            }&#10;            .create()&#10;            .show()&#10;    }&#10;&#10;    /**&#10;     * Shows a dialog prompting the user to go to settings to enable permissions&#10;     */&#10;    private fun showSettingsPrompt() {&#10;        AlertDialog.Builder(activity)&#10;            .setTitle(&quot;Permissions Required&quot;)&#10;            .setMessage(&quot;Some features require location permissions that were denied. Please enable them in app settings.&quot;)&#10;            .setPositiveButton(&quot;Settings&quot;) { _, _ -&gt;&#10;                // Open app settings&#10;                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)&#10;                val uri = Uri.fromParts(&quot;package&quot;, activity.packageName, null)&#10;                intent.data = uri&#10;                activity.startActivity(intent)&#10;            }&#10;            .setNegativeButton(&quot;Not Now&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;            }&#10;            .create()&#10;            .show()&#10;    }&#10;&#10;    /**&#10;     * Check if a permission is granted&#10;     */&#10;    private fun hasPermission(context: Context, permission: String): Boolean {&#10;        return ContextCompat.checkSelfPermission(&#10;            context,&#10;            permission&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/LoginActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/LoginActivity.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.viewModels&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import javax.inject.Inject&#10;&#10;@AndroidEntryPoint&#10;class LoginActivity : ComponentActivity() {&#10;&#10;    @Inject&#10;    lateinit var googleSignInManager: GoogleSignInManager&#10;&#10;    private val viewModel: AuthViewModel by viewModels()&#10;    private lateinit var googleSignInLauncher: ActivityResultLauncher&lt;Intent&gt;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Initialize Google Sign-In client&#10;        googleSignInManager.init(this)&#10;&#10;        // Register for Google Sign-In activity result&#10;        googleSignInLauncher = registerForActivityResult(&#10;            ActivityResultContracts.StartActivityForResult()&#10;        ) { result -&gt;&#10;            // Handle the result&#10;            val idToken = googleSignInManager.handleSignInResult(result.data)&#10;            if (idToken != null) {&#10;                // Pass the ID token to the ViewModel for Firebase authentication&#10;                viewModel.signInWithGoogle(idToken)&#10;            } else {&#10;                Toast.makeText(this, &quot;Google Sign-In failed&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        setContent {&#10;            MaterialTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    LoginScreen(&#10;                        viewModel = viewModel,&#10;                        onGoogleSignInClick = { startGoogleSignIn() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startGoogleSignIn() {&#10;        // Launch Google Sign-In flow&#10;        val signInIntent = googleSignInManager.getSignInIntent()&#10;        googleSignInLauncher.launch(signInIntent)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LoginScreen(&#10;    viewModel: AuthViewModel,&#10;    onGoogleSignInClick: () -&gt; Unit&#10;) {&#10;    val signInState by viewModel.signInState.collectAsState()&#10;    val context = LocalContext.current&#10;&#10;    // Observe authentication state changes&#10;    LaunchedEffect(signInState) {&#10;        when (signInState) {&#10;            is AuthState.Success -&gt; {&#10;                // Handle successful sign-in&#10;                Toast.makeText(context, (signInState as AuthState.Success).message, Toast.LENGTH_SHORT).show()&#10;&#10;                // Navigate to main screen or perform other actions after successful sign-in&#10;                // Example: context.startActivity(Intent(context, MainActivity::class.java))&#10;            }&#10;            is AuthState.Error -&gt; {&#10;                // Display error message&#10;                Toast.makeText(context, (signInState as AuthState.Error).message, Toast.LENGTH_LONG).show()&#10;            }&#10;            is AuthState.Info -&gt; {&#10;                // Display info message&#10;                Toast.makeText(context, (signInState as AuthState.Info).message, Toast.LENGTH_SHORT).show()&#10;            }&#10;            else -&gt; {} // Handle other states if needed&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Welcome&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Google Sign-In button&#10;        Button(&#10;            onClick = onGoogleSignInClick,&#10;            modifier = Modifier.fillMaxWidth(0.8f)&#10;        ) {&#10;            Text(text = &quot;Sign in with Google&quot;)&#10;        }&#10;&#10;        // You can add more authentication options (email/password) here&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.viewModels&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import javax.inject.Inject&#10;&#10;@AndroidEntryPoint&#10;class LoginActivity : ComponentActivity() {&#10;&#10;    @Inject&#10;    lateinit var googleSignInManager: GoogleSignInManager&#10;&#10;    private val viewModel: AuthViewModel by viewModels()&#10;    private lateinit var googleSignInLauncher: ActivityResultLauncher&lt;Intent&gt;&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Initialize Google Sign-In client&#10;        googleSignInManager.init(this)&#10;&#10;        // Register for Google Sign-In activity result&#10;        googleSignInLauncher = registerForActivityResult(&#10;            ActivityResultContracts.StartActivityForResult()&#10;        ) { result -&gt;&#10;            // Handle the result&#10;            val idToken = googleSignInManager.handleSignInResult(result.data)&#10;            if (idToken != null) {&#10;                // Pass the ID token to the ViewModel for Firebase authentication&#10;                viewModel.signInWithGoogle(idToken)&#10;            } else {&#10;                Toast.makeText(this, &quot;Google Sign-In failed&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;&#10;        setContent {&#10;            MaterialTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    LoginScreen(&#10;                        viewModel = viewModel,&#10;                        onGoogleSignInClick = { startGoogleSignIn() },&#10;                        onNavigateToMain = {&#10;                            startActivity(Intent(this, MainActivity::class.java))&#10;                            finish()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startGoogleSignIn() {&#10;        // Launch Google Sign-In flow&#10;        val signInIntent = googleSignInManager.getSignInIntent()&#10;        googleSignInLauncher.launch(signInIntent)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LoginScreen(&#10;    viewModel: AuthViewModel,&#10;    onGoogleSignInClick: () -&gt; Unit,&#10;    onNavigateToMain: () -&gt; Unit&#10;) {&#10;    val signInState by viewModel.signInState.collectAsState()&#10;    val context = LocalContext.current&#10;&#10;    // Observe authentication state changes&#10;    LaunchedEffect(signInState) {&#10;        when (signInState) {&#10;            is AuthState.Success -&gt; {&#10;                // Handle successful sign-in&#10;                Toast.makeText(context, (signInState as AuthState.Success).message, Toast.LENGTH_SHORT).show()&#10;&#10;                // Navigate to main screen or perform other actions after successful sign-in&#10;                onNavigateToMain()&#10;            }&#10;            is AuthState.Error -&gt; {&#10;                // Display error message&#10;                Toast.makeText(context, (signInState as AuthState.Error).message, Toast.LENGTH_LONG).show()&#10;            }&#10;            is AuthState.Info -&gt; {&#10;                // Display info message&#10;                Toast.makeText(context, (signInState as AuthState.Info).message, Toast.LENGTH_SHORT).show()&#10;            }&#10;            else -&gt; {} // Handle other states if needed&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;Welcome&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        // Google Sign-In button&#10;        Button(&#10;            onClick = onGoogleSignInClick,&#10;            modifier = Modifier.fillMaxWidth(0.8f)&#10;        ) {&#10;            Text(text = &quot;Sign in with Google&quot;)&#10;        }&#10;&#10;        // You can add more authentication options (email/password) here&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/MainActivity.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.WindowManager&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Modifier&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.repeatOnLifecycle&#10;import com.google.ai.edge.gallery.ui.theme.GalleryTheme&#10;import com.google.firebase.analytics.FirebaseAnalytics&#10;// Removed Firebase KTX imports to avoid dependency on analytics-ktx&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;&#10;  private var firebaseAnalytics: FirebaseAnalytics? = null&#10;&#10;  // Inject GeofenceManager&#10;  @Inject&#10;  lateinit var geofenceManager: GeofenceManager&#10;&#10;  // Location permission helper&#10;  private lateinit var locationPermissionHelper: LocationPermissionHelper&#10;&#10;  override fun onCreate(savedInstanceState: Bundle?) {&#10;    firebaseAnalytics =&#10;      runCatching { FirebaseAnalytics.getInstance(this) }&#10;        .onFailure { exception -&gt;&#10;          // Firebase Analytics can throw an exception if google-services is not set up, e.g.,&#10;          // missing google-services.json.&#10;          Log.w(TAG, &quot;Firebase Analytics is not available&quot;, exception)&#10;        }&#10;        .getOrNull()&#10;&#10;    installSplashScreen()&#10;&#10;    super.onCreate(savedInstanceState)&#10;    enableEdgeToEdge()&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;      // Fix for three-button nav not properly going edge-to-edge.&#10;      // See: https://issuetracker.google.com/issues/298296168&#10;      window.isNavigationBarContrastEnforced = false&#10;    }&#10;&#10;    // Initialize location permission helper&#10;    locationPermissionHelper = LocationPermissionHelper(this)&#10;&#10;    setContent { GalleryTheme { Surface(modifier = Modifier.fillMaxSize()) { GalleryApp() } } }&#10;    // Keep the screen on while the app is running for better demo experience.&#10;    window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;    // Initialize geofencing when the activity is created&#10;    setupGeofencing()&#10;&#10;    // Observe geofence events&#10;    observeGeofenceEvents()&#10;  }&#10;&#10;  /**&#10;   * Sets up geofencing by requesting permissions and registering geofence locations&#10;   */&#10;  private fun setupGeofencing() {&#10;    // Request location permissions first&#10;    if (locationPermissionHelper.requestLocationPermissions()) {&#10;      // Permissions are already granted, register geofences&#10;      registerSampleGeofences()&#10;    }&#10;    // If permissions aren't granted, the permission flow will continue in onResume&#10;  }&#10;&#10;  /**&#10;   * Registers sample geofence locations for demonstration&#10;   * In a real app, you would get these locations from your database or user preferences&#10;   */&#10;  private fun registerSampleGeofences() {&#10;    // Example locations - replace with actual locations relevant to your app&#10;    val geofenceLocations = listOf(&#10;      GeofenceLocation(&#10;        id = &quot;university_campus&quot;,&#10;        latitude = 23.8175, // Example coordinates for North South University&#10;        longitude = 90.4272,&#10;        radius = 200f // 200 meters&#10;      ),&#10;      GeofenceLocation(&#10;        id = &quot;library&quot;,&#10;        latitude = 23.8165,&#10;        longitude = 90.4260,&#10;        radius = 50f // 50 meters&#10;      )&#10;    )&#10;&#10;    // Register the geofences&#10;    geofenceManager.registerGeofences(geofenceLocations)&#10;  }&#10;&#10;  override fun onResume() {&#10;    super.onResume()&#10;    // Check permissions again in case the user returned from settings&#10;    if (locationPermissionHelper.requestLocationPermissions()) {&#10;      // Permissions granted, register geofences if needed&#10;      registerSampleGeofences()&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Observes geofence events from the GeofenceRepository&#10;   */&#10;  private fun observeGeofenceEvents() {&#10;    lifecycleScope.launch {&#10;      repeatOnLifecycle(Lifecycle.State.STARTED) {&#10;        GeofenceRepository.lastEnteredGeofenceId.collectLatest { geofenceId -&gt;&#10;          if (geofenceId != null) {&#10;            // Display a toast message when a geofence is entered&#10;            val message = &quot;Entered geofence: $geofenceId&quot;&#10;            Toast.makeText(this@MainActivity, message, Toast.LENGTH_LONG).show()&#10;            Log.d(TAG, message)&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  companion object {&#10;    private const val TAG = &quot;AGMainActivity&quot;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.WindowManager&#10;import android.widget.Toast&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Modifier&#10;import androidx.core.splashscreen.SplashScreen.Companion.installSplashScreen&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.repeatOnLifecycle&#10;import com.google.ai.edge.gallery.ui.theme.GalleryTheme&#10;import com.google.firebase.analytics.FirebaseAnalytics&#10;// Removed Firebase KTX imports to avoid dependency on analytics-ktx&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;&#10;  private var firebaseAnalytics: FirebaseAnalytics? = null&#10;&#10;  // Inject GeofenceManager&#10;  @Inject&#10;  lateinit var geofenceManager: GeofenceManager&#10;&#10;  // Location permission helper&#10;  private lateinit var locationPermissionHelper: LocationPermissionHelper&#10;&#10;  override fun onCreate(savedInstanceState: Bundle?) {&#10;    firebaseAnalytics =&#10;      runCatching { FirebaseAnalytics.getInstance(this) }&#10;        .onFailure { exception -&gt;&#10;          // Firebase Analytics can throw an exception if google-services is not set up, e.g.,&#10;          // missing google-services.json.&#10;          Log.w(TAG, &quot;Firebase Analytics is not available&quot;, exception)&#10;        }&#10;        .getOrNull()&#10;&#10;    installSplashScreen()&#10;&#10;    super.onCreate(savedInstanceState)&#10;    enableEdgeToEdge()&#10;    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;      // Fix for three-button nav not properly going edge-to-edge.&#10;      // See: https://issuetracker.google.com/issues/298296168&#10;      window.isNavigationBarContrastEnforced = false&#10;    }&#10;&#10;    // Initialize location permission helper&#10;    locationPermissionHelper = LocationPermissionHelper(this)&#10;&#10;    setContent { GalleryTheme { Surface(modifier = Modifier.fillMaxSize()) { GalleryApp() } } }&#10;    // Keep the screen on while the app is running for better demo experience.&#10;    window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;    // Initialize geofencing when the activity is created&#10;    setupGeofencing()&#10;&#10;    // Observe geofence events&#10;    observeGeofenceEvents()&#10;  }&#10;&#10;  /**&#10;   * Sets up geofencing by requesting permissions and registering geofence locations&#10;   */&#10;  private fun setupGeofencing() {&#10;    // Request location permissions first&#10;    if (locationPermissionHelper.requestLocationPermissions()) {&#10;      // Permissions are already granted, register geofences&#10;      registerSampleGeofences()&#10;    }&#10;    // If permissions aren't granted, the permission flow will continue in onResume&#10;  }&#10;&#10;  /**&#10;   * Registers sample geofence locations for demonstration&#10;   * In a real app, you would get these locations from your database or user preferences&#10;   */&#10;  private fun registerSampleGeofences() {&#10;    // Example locations - replace with actual locations relevant to your app&#10;    val geofenceLocations = getGeofenceLocations()&#10;&#10;    // Register the geofences&#10;    addGeofences(geofenceLocations)&#10;  }&#10;&#10;  /**&#10;   * Gets a list of geofence locations to monitor&#10;   * This could be replaced with data from a database, API, or user preferences&#10;   *&#10;   * @return List of GeofenceLocation objects&#10;   */&#10;  private fun getGeofenceLocations(): List&lt;GeofenceLocation&gt; {&#10;    // In a real app, you would fetch this data from a database or API&#10;    return listOf(&#10;      GeofenceLocation(&#10;        id = &quot;university_campus&quot;,&#10;        latitude = 23.8175, // Example coordinates for North South University&#10;        longitude = 90.4272,&#10;        radius = 200f // 200 meters&#10;      ),&#10;      GeofenceLocation(&#10;        id = &quot;library&quot;,&#10;        latitude = 23.8165,&#10;        longitude = 90.4260,&#10;        radius = 50f // 50 meters&#10;      ),&#10;      GeofenceLocation(&#10;        id = &quot;cafeteria&quot;,&#10;        latitude = 23.8170,&#10;        longitude = 90.4265,&#10;        radius = 30f // 30 meters&#10;      )&#10;    )&#10;  }&#10;&#10;  /**&#10;   * Adds multiple geofences for monitoring&#10;   *&#10;   * @param locations List of geofence locations to monitor&#10;   */&#10;  private fun addGeofences(locations: List&lt;GeofenceLocation&gt;) {&#10;    if (locations.isEmpty()) {&#10;      Log.d(TAG, &quot;No geofence locations provided&quot;)&#10;      return&#10;    }&#10;&#10;    Log.d(TAG, &quot;Adding ${locations.size} geofences&quot;)&#10;    geofenceManager.registerGeofences(locations)&#10;  }&#10;&#10;  override fun onResume() {&#10;    super.onResume()&#10;    // Check permissions again in case the user returned from settings&#10;    if (locationPermissionHelper.requestLocationPermissions()) {&#10;      // Permissions granted, register geofences if needed&#10;      registerSampleGeofences()&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Observes geofence events from the GeofenceRepository&#10;   */&#10;  private fun observeGeofenceEvents() {&#10;    lifecycleScope.launch {&#10;      repeatOnLifecycle(Lifecycle.State.STARTED) {&#10;        GeofenceRepository.lastEnteredGeofenceId.collectLatest { geofenceId -&gt;&#10;          if (geofenceId != null) {&#10;            // Display a toast message when a geofence is entered&#10;            val message = &quot;Entered geofence: $geofenceId&quot;&#10;            Toast.makeText(this@MainActivity, message, Toast.LENGTH_LONG).show()&#10;            Log.d(TAG, message)&#10;          }&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  companion object {&#10;    private const val TAG = &quot;AGMainActivity&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/MessageBridgeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/MessageBridgeViewModel.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.bridge&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailConnectionState&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailLabel&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailService&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramChat&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramConnectionState&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramService&#10;import com.google.android.gms.auth.api.signin.GoogleSignInAccount&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class MessageBridgeViewModel @Inject constructor(&#10;    private val telegramService: TelegramService,&#10;    private val gmailService: GmailService&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;MessageBridgeViewModel&quot;&#10;&#10;    // UI state&#10;    private val _uiState = MutableStateFlow&lt;MessageBridgeUiState&gt;(MessageBridgeUiState.Loading)&#10;    val uiState: StateFlow&lt;MessageBridgeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Bridge rules&#10;    val bridgeRules = MessageBridgeRepository.bridgeRules&#10;&#10;    // Recent messages&#10;    val recentMessages = MessageBridgeRepository.recentMessages&#10;&#10;    // Connection states&#10;    val telegramConnected = MessageBridgeRepository.telegramConnected&#10;    val gmailConnected = MessageBridgeRepository.gmailConnected&#10;&#10;    // Telegram chats&#10;    val telegramChats = telegramService.chats&#10;&#10;    // Gmail labels&#10;    val gmailLabels = gmailService.labels&#10;&#10;    // Connection states&#10;    val telegramConnectionState = telegramService.connectionState&#10;    val gmailConnectionState = gmailService.connectionState&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            // Monitor Telegram connection state&#10;            telegramService.connectionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    TelegramConnectionState.CONNECTED -&gt; {&#10;                        updateUiState()&#10;                        telegramService.loadChats()&#10;                    }&#10;                    TelegramConnectionState.ERROR -&gt; {&#10;                        _uiState.value = MessageBridgeUiState.Error(&quot;Telegram connection error&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        updateUiState()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Monitor Gmail connection state&#10;            gmailService.connectionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    GmailConnectionState.CONNECTED -&gt; {&#10;                        updateUiState()&#10;                        gmailService.loadRecentMessages()&#10;                    }&#10;                    GmailConnectionState.ERROR -&gt; {&#10;                        _uiState.value = MessageBridgeUiState.Error(&quot;Gmail connection error&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        updateUiState()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Updates the UI state based on current connection states&#10;     */&#10;    private fun updateUiState() {&#10;        val telegramState = telegramService.connectionState.value&#10;        val gmailState = gmailService.connectionState.value&#10;&#10;        _uiState.value = when {&#10;            telegramState == TelegramConnectionState.CONNECTED &amp;&amp;&#10;                    gmailState == GmailConnectionState.CONNECTED -&gt; {&#10;                MessageBridgeUiState.BothConnected&#10;            }&#10;            telegramState == TelegramConnectionState.CONNECTED -&gt; {&#10;                MessageBridgeUiState.TelegramOnlyConnected&#10;            }&#10;            gmailState == GmailConnectionState.CONNECTED -&gt; {&#10;                MessageBridgeUiState.GmailOnlyConnected&#10;            }&#10;            telegramState == TelegramConnectionState.WAITING_FOR_PHONE ||&#10;                    telegramState == TelegramConnectionState.WAITING_FOR_CODE ||&#10;                    telegramState == TelegramConnectionState.WAITING_FOR_PASSWORD -&gt; {&#10;                MessageBridgeUiState.TelegramAuthInProgress(telegramState)&#10;            }&#10;            gmailState == GmailConnectionState.CONNECTING -&gt; {&#10;                MessageBridgeUiState.GmailAuthInProgress&#10;            }&#10;            else -&gt; {&#10;                MessageBridgeUiState.NoneConnected&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Initializes the Telegram client&#10;     */&#10;    fun initializeTelegram(apiId: Int, apiHash: String) {&#10;        telegramService.initialize(apiId, apiHash)&#10;    }&#10;&#10;    /**&#10;     * Starts Telegram authentication with a phone number&#10;     */&#10;    fun startTelegramAuth(phoneNumber: String) {&#10;        telegramService.startAuthentication(phoneNumber)&#10;    }&#10;&#10;    /**&#10;     * Submits the Telegram authentication code&#10;     */&#10;    fun submitTelegramCode(code: String) {&#10;        telegramService.submitAuthCode(code)&#10;    }&#10;&#10;    /**&#10;     * Submits the Telegram password for 2FA&#10;     */&#10;    fun submitTelegramPassword(password: String) {&#10;        telegramService.submitPassword(password)&#10;    }&#10;&#10;    /**&#10;     * Logs out from Telegram&#10;     */&#10;    fun disconnectTelegram() {&#10;        telegramService.logout()&#10;    }&#10;&#10;    /**&#10;     * Initializes the Gmail service with a Google account&#10;     */&#10;    fun initializeGmail(account: GoogleSignInAccount) {&#10;        gmailService.initializeGmailService(account)&#10;    }&#10;&#10;    /**&#10;     * Disconnects from Gmail&#10;     */&#10;    fun disconnectGmail() {&#10;        gmailService.disconnect()&#10;    }&#10;&#10;    /**&#10;     * Gets the Google Sign-In options needed for Gmail&#10;     */&#10;    fun getGoogleSignInOptions() = gmailService.getGoogleSignInOptions()&#10;&#10;    /**&#10;     * Adds a new bridge rule&#10;     */&#10;    fun addBridgeRule(rule: BridgeRule): Boolean {&#10;        return MessageBridgeRepository.addBridgeRule(rule)&#10;    }&#10;&#10;    /**&#10;     * Removes a bridge rule&#10;     */&#10;    fun removeBridgeRule(ruleId: String): Boolean {&#10;        return MessageBridgeRepository.removeBridgeRule(ruleId)&#10;    }&#10;&#10;    /**&#10;     * Sends a test message via Telegram&#10;     */&#10;    fun sendTelegramMessage(&#10;        chatId: String,&#10;        text: String,&#10;        onSuccess: () -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        telegramService.sendMessage(chatId, text, onSuccess, onError)&#10;    }&#10;&#10;    /**&#10;     * Sends a test email via Gmail&#10;     */&#10;    fun sendEmail(&#10;        to: String,&#10;        subject: String,&#10;        body: String,&#10;        onSuccess: () -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        gmailService.sendEmail(to, subject, body, onSuccess, onError)&#10;    }&#10;&#10;    /**&#10;     * Clears the recent messages history&#10;     */&#10;    fun clearRecentMessages() {&#10;        MessageBridgeRepository.clearRecentMessages()&#10;    }&#10;}&#10;&#10;/**&#10; * Sealed class representing the various UI states for the message bridge&#10; */&#10;sealed class MessageBridgeUiState {&#10;    object Loading : MessageBridgeUiState()&#10;    object NoneConnected : MessageBridgeUiState()&#10;    object TelegramOnlyConnected : MessageBridgeUiState()&#10;    object GmailOnlyConnected : MessageBridgeUiState()&#10;    object BothConnected : MessageBridgeUiState()&#10;    data class TelegramAuthInProgress(val state: TelegramConnectionState) : MessageBridgeUiState()&#10;    object GmailAuthInProgress : MessageBridgeUiState()&#10;    data class Error(val message: String) : MessageBridgeUiState()&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailConnectionState&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailLabel&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailService&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramChat&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramConnectionState&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramService&#10;import com.google.android.gms.auth.api.signin.GoogleSignInAccount&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class MessageBridgeViewModel @Inject constructor(&#10;    private val telegramService: TelegramService,&#10;    private val gmailService: GmailService&#10;) : ViewModel() {&#10;&#10;    private val TAG = &quot;MessageBridgeViewModel&quot;&#10;&#10;    // UI state&#10;    private val _uiState = MutableStateFlow&lt;MessageBridgeUiState&gt;(MessageBridgeUiState.Loading)&#10;    val uiState: StateFlow&lt;MessageBridgeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Bridge rules&#10;    val bridgeRules = MessageBridgeRepository.bridgeRules&#10;&#10;    // Recent messages&#10;    val recentMessages = MessageBridgeRepository.recentMessages&#10;&#10;    // Connection states&#10;    val telegramConnected = MessageBridgeRepository.telegramConnected&#10;    val gmailConnected = MessageBridgeRepository.gmailConnected&#10;&#10;    // Telegram chats&#10;    val telegramChats = telegramService.chats&#10;&#10;    // Gmail labels&#10;    val gmailLabels = gmailService.labels&#10;&#10;    // Connection states&#10;    val telegramConnectionState = telegramService.connectionState&#10;    val gmailConnectionState = gmailService.connectionState&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            // Monitor Telegram connection state&#10;            telegramService.connectionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    TelegramConnectionState.CONNECTED -&gt; {&#10;                        updateUiState()&#10;                        telegramService.loadChats()&#10;                    }&#10;                    TelegramConnectionState.ERROR -&gt; {&#10;                        _uiState.value = MessageBridgeUiState.Error(&quot;Telegram connection error&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        updateUiState()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            // Monitor Gmail connection state&#10;            gmailService.connectionState.collectLatest { state -&gt;&#10;                when (state) {&#10;                    GmailConnectionState.CONNECTED -&gt; {&#10;                        updateUiState()&#10;                        gmailService.loadRecentMessages()&#10;                    }&#10;                    GmailConnectionState.ERROR -&gt; {&#10;                        _uiState.value = MessageBridgeUiState.Error(&quot;Gmail connection error&quot;)&#10;                    }&#10;                    else -&gt; {&#10;                        updateUiState()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Updates the UI state based on current connection states&#10;     */&#10;    private fun updateUiState() {&#10;        val telegramState = telegramService.connectionState.value&#10;        val gmailState = gmailService.connectionState.value&#10;&#10;        _uiState.value = when {&#10;            telegramState == TelegramConnectionState.CONNECTED &amp;&amp;&#10;                    gmailState == GmailConnectionState.CONNECTED -&gt; {&#10;                MessageBridgeUiState.BothConnected&#10;            }&#10;            telegramState == TelegramConnectionState.CONNECTED -&gt; {&#10;                MessageBridgeUiState.TelegramOnlyConnected&#10;            }&#10;            gmailState == GmailConnectionState.CONNECTED -&gt; {&#10;                MessageBridgeUiState.GmailOnlyConnected&#10;            }&#10;            telegramState == TelegramConnectionState.WAITING_FOR_PHONE ||&#10;                    telegramState == TelegramConnectionState.WAITING_FOR_CODE ||&#10;                    telegramState == TelegramConnectionState.WAITING_FOR_PASSWORD -&gt; {&#10;                MessageBridgeUiState.TelegramAuthInProgress(telegramState)&#10;            }&#10;            gmailState == GmailConnectionState.CONNECTING -&gt; {&#10;                MessageBridgeUiState.GmailAuthInProgress&#10;            }&#10;            else -&gt; {&#10;                MessageBridgeUiState.NoneConnected&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Initializes the Telegram client&#10;     */&#10;    fun initializeTelegram(apiId: Int, apiHash: String) {&#10;        telegramService.initialize(apiId, apiHash)&#10;    }&#10;&#10;    /**&#10;     * Starts Telegram authentication with a phone number&#10;     */&#10;    fun startTelegramAuth(phoneNumber: String) {&#10;        telegramService.startAuthentication(phoneNumber)&#10;    }&#10;&#10;    /**&#10;     * Submits the Telegram authentication code&#10;     */&#10;    fun submitTelegramCode(code: String) {&#10;        telegramService.submitAuthCode(code)&#10;    }&#10;&#10;    /**&#10;     * Submits the Telegram password for 2FA&#10;     */&#10;    fun submitTelegramPassword(password: String) {&#10;        telegramService.submitPassword(password)&#10;    }&#10;&#10;    /**&#10;     * Logs out from Telegram&#10;     */&#10;    fun disconnectTelegram() {&#10;        telegramService.logout()&#10;    }&#10;&#10;    /**&#10;     * Initializes the Gmail service with a Google account&#10;     */&#10;    fun initializeGmail(account: GoogleSignInAccount) {&#10;        gmailService.initializeGmailService(account)&#10;    }&#10;&#10;    /**&#10;     * Disconnects from Gmail&#10;     */&#10;    fun disconnectGmail() {&#10;        gmailService.disconnect()&#10;    }&#10;&#10;    /**&#10;     * Gets the Google Sign-In options needed for Gmail&#10;     */&#10;    fun getGoogleSignInOptions() = gmailService.getGoogleSignInOptions()&#10;&#10;    /**&#10;     * Adds a new bridge rule&#10;     */&#10;    fun addBridgeRule(rule: BridgeRule): Boolean {&#10;        val added = MessageBridgeRepository.addBridgeRule(rule)&#10;        if (added) {&#10;            // Start the bridge service when a rule is added&#10;            MessageBridgeService.start(getApplication())&#10;            registerGeofences()&#10;        }&#10;        return added&#10;    }&#10;&#10;    /**&#10;     * Initializes the bridge service if there are active rules&#10;     */&#10;    fun initializeBridgeServiceIfNeeded() {&#10;        val rules = MessageBridgeRepository.bridgeRules.value&#10;        if (rules.isNotEmpty() &amp;&amp; rules.any { it.enabled }) {&#10;            MessageBridgeService.start(getApplication())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Removes a bridge rule&#10;     */&#10;    fun removeBridgeRule(ruleId: String): Boolean {&#10;        return MessageBridgeRepository.removeBridgeRule(ruleId)&#10;    }&#10;&#10;    /**&#10;     * Sends a test message via Telegram&#10;     */&#10;    fun sendTelegramMessage(&#10;        chatId: String,&#10;        text: String,&#10;        onSuccess: () -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        telegramService.sendMessage(chatId, text, onSuccess, onError)&#10;    }&#10;&#10;    /**&#10;     * Sends a test email via Gmail&#10;     */&#10;    fun sendEmail(&#10;        to: String,&#10;        subject: String,&#10;        body: String,&#10;        onSuccess: () -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        gmailService.sendEmail(to, subject, body, onSuccess, onError)&#10;    }&#10;&#10;    /**&#10;     * Clears the recent messages history&#10;     */&#10;    fun clearRecentMessages() {&#10;        MessageBridgeRepository.clearRecentMessages()&#10;    }&#10;}&#10;&#10;/**&#10; * Sealed class representing the various UI states for the message bridge&#10; */&#10;sealed class MessageBridgeUiState {&#10;    object Loading : MessageBridgeUiState()&#10;    object NoneConnected : MessageBridgeUiState()&#10;    object TelegramOnlyConnected : MessageBridgeUiState()&#10;    object GmailOnlyConnected : MessageBridgeUiState()&#10;    object BothConnected : MessageBridgeUiState()&#10;    data class TelegramAuthInProgress(val state: TelegramConnectionState) : MessageBridgeUiState()&#10;    object GmailAuthInProgress : MessageBridgeUiState()&#10;    data class Error(val message: String) : MessageBridgeUiState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/fcm/BridgeMessagingService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/fcm/BridgeMessagingService.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.bridge.fcm&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.media.RingtoneManager&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import com.google.ai.edge.gallery.MainActivity&#10;import com.google.ai.edge.gallery.R&#10;import com.google.ai.edge.gallery.bridge.service.MessageBridgeService&#10;import com.google.firebase.messaging.FirebaseMessagingService&#10;import com.google.firebase.messaging.RemoteMessage&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Service that handles Firebase Cloud Messaging notifications.&#10; * Used for receiving notifications about new messages from Telegram and Gmail.&#10; */&#10;@AndroidEntryPoint&#10;class BridgeMessagingService : FirebaseMessagingService() {&#10;    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;    private val fcmTokenManager by lazy { FCMTokenManager(applicationContext) }&#10;&#10;    companion object {&#10;        private const val TAG = &quot;BridgeMessagingService&quot;&#10;        private const val CHANNEL_ID = &quot;message_bridge_channel&quot;&#10;    }&#10;    &#10;    override fun onNewToken(token: String) {&#10;        super.onNewToken(token)&#10;        Log.d(TAG, &quot;New FCM token: $token&quot;)&#10;        &#10;        // Register the token with our backend&#10;        serviceScope.launch {&#10;            fcmTokenManager.getAndRegisterFCMToken()&#10;        }&#10;    }&#10;    &#10;    override fun onMessageReceived(message: RemoteMessage) {&#10;        super.onMessageReceived(message)&#10;        Log.d(TAG, &quot;Message received from: ${message.from}&quot;)&#10;        &#10;        // Extract message data&#10;        val data = message.data&#10;        &#10;        // Check if this is a bridge-related message&#10;        if (data.containsKey(&quot;type&quot;)) {&#10;            // Process the message based on type&#10;            when (data[&quot;type&quot;]) {&#10;                &quot;telegram&quot; -&gt; processTelegramNotification(data)&#10;                &quot;gmail&quot; -&gt; processGmailNotification(data)&#10;            }&#10;            &#10;            // Start the bridge service to process any pending messages&#10;            MessageBridgeService.start(applicationContext)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Process a notification about new Telegram messages&#10;     */&#10;    private fun processTelegramNotification(data: Map&lt;String, String&gt;) {&#10;        val chatId = data[&quot;chat_id&quot;] ?: return&#10;        val chatName = data[&quot;chat_name&quot;] ?: &quot;Telegram&quot;&#10;        val messageCount = data[&quot;message_count&quot;]?.toIntOrNull() ?: 1&#10;        &#10;        // Create and show notification&#10;        val title = &quot;New Telegram message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;}&quot;&#10;        val text = &quot;You have $messageCount new message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;} in $chatName&quot;&#10;        &#10;        showNotification(title, text)&#10;        &#10;        // Trigger message processing in the background&#10;        serviceScope.launch {&#10;            // In a real implementation, you would trigger immediate processing&#10;            // of messages from this chat&#10;            Log.d(TAG, &quot;Would process new Telegram messages from chat $chatId&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Process a notification about new Gmail messages&#10;     */&#10;    private fun processGmailNotification(data: Map&lt;String, String&gt;) {&#10;        val label = data[&quot;label&quot;] ?: &quot;Inbox&quot;&#10;        val messageCount = data[&quot;message_count&quot;]?.toIntOrNull() ?: 1&#10;        &#10;        // Create and show notification&#10;        val title = &quot;New Gmail message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;}&quot;&#10;        val text = &quot;You have $messageCount new message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;} in $label&quot;&#10;        &#10;        showNotification(title, text)&#10;        &#10;        // Trigger message processing in the background&#10;        serviceScope.launch {&#10;            // In a real implementation, you would trigger immediate processing&#10;            // of messages from this label&#10;            Log.d(TAG, &quot;Would process new Gmail messages from label $label&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Shows a notification to the user&#10;     */&#10;    private fun showNotification(title: String, text: String) {&#10;        // Create notification channel for Android O and above&#10;        createNotificationChannel()&#10;        &#10;        // Create intent for when notification is tapped&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)&#10;            putExtra(&quot;openBridge&quot;, true)&#10;        }&#10;        &#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_ONE_SHOT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;        &#10;        // Build the notification&#10;        val notificationBuilder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground) // Use an appropriate icon&#10;            .setContentTitle(title)&#10;            .setContentText(text)&#10;            .setAutoCancel(true)&#10;            .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION))&#10;            .setContentIntent(pendingIntent)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;        &#10;        // Show the notification&#10;        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        val notificationId = System.currentTimeMillis().toInt()&#10;        notificationManager.notify(notificationId, notificationBuilder.build())&#10;    }&#10;    &#10;    /**&#10;     * Creates the notification channel for Android O and above&#10;     */&#10;    private fun createNotificationChannel() {&#10;        // Create notification channel for Android O and above&#10;        val name = &quot;Message Bridge&quot;&#10;        val description = &quot;Notifications for Telegram and Gmail messages&quot;&#10;        val importance = NotificationManager.IMPORTANCE_HIGH&#10;&#10;        val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;            this.description = description&#10;            enableVibration(true)&#10;        }&#10;&#10;        // Register the channel with the system&#10;        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        notificationManager.createNotificationChannel(channel)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.fcm&#10;&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.media.RingtoneManager&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import com.google.ai.edge.gallery.MainActivity&#10;import com.google.ai.edge.gallery.R&#10;import com.google.ai.edge.gallery.bridge.service.MessageBridgeService&#10;import com.google.firebase.messaging.FirebaseMessagingService&#10;import com.google.firebase.messaging.RemoteMessage&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Service that handles Firebase Cloud Messaging notifications.&#10; * Used for receiving notifications about new messages from Telegram and Gmail.&#10; */&#10;@AndroidEntryPoint&#10;class BridgeMessagingService : FirebaseMessagingService() {&#10;    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;    private val fcmTokenManager by lazy { FCMTokenManager(context = applicationContext) }&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;BridgeMessagingService&quot;&#10;        private const val CHANNEL_ID = &quot;message_bridge_channel&quot;&#10;    }&#10;    &#10;    override fun onNewToken(token: String) {&#10;        super.onNewToken(token)&#10;        Log.d(TAG, &quot;New FCM token: $token&quot;)&#10;        &#10;        // Register the token with our backend&#10;        serviceScope.launch {&#10;            fcmTokenManager.getAndRegisterFCMToken()&#10;        }&#10;    }&#10;    &#10;    override fun onMessageReceived(message: RemoteMessage) {&#10;        super.onMessageReceived(message)&#10;        Log.d(TAG, &quot;Message received from: ${message.from}&quot;)&#10;        &#10;        // Extract message data&#10;        val data = message.data&#10;        &#10;        // Check if this is a bridge-related message&#10;        if (data.containsKey(&quot;type&quot;)) {&#10;            // Process the message based on type&#10;            when (data[&quot;type&quot;]) {&#10;                &quot;telegram&quot; -&gt; processTelegramNotification(data)&#10;                &quot;gmail&quot; -&gt; processGmailNotification(data)&#10;            }&#10;            &#10;            // Start the bridge service to process any pending messages&#10;            MessageBridgeService.start(applicationContext)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Process a notification about new Telegram messages&#10;     */&#10;    private fun processTelegramNotification(data: Map&lt;String, String&gt;) {&#10;        val chatId = data[&quot;chat_id&quot;] ?: return&#10;        val chatName = data[&quot;chat_name&quot;] ?: &quot;Telegram&quot;&#10;        val messageCount = data[&quot;message_count&quot;]?.toIntOrNull() ?: 1&#10;        &#10;        // Create and show notification&#10;        val title = &quot;New Telegram message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;}&quot;&#10;        val text = &quot;You have $messageCount new message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;} in $chatName&quot;&#10;        &#10;        showNotification(title, text)&#10;        &#10;        // Trigger message processing in the background&#10;        serviceScope.launch {&#10;            // In a real implementation, you would trigger immediate processing&#10;            // of messages from this chat&#10;            Log.d(TAG, &quot;Would process new Telegram messages from chat $chatId&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Process a notification about new Gmail messages&#10;     */&#10;    private fun processGmailNotification(data: Map&lt;String, String&gt;) {&#10;        val label = data[&quot;label&quot;] ?: &quot;Inbox&quot;&#10;        val messageCount = data[&quot;message_count&quot;]?.toIntOrNull() ?: 1&#10;        &#10;        // Create and show notification&#10;        val title = &quot;New Gmail message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;}&quot;&#10;        val text = &quot;You have $messageCount new message${if (messageCount &gt; 1) &quot;s&quot; else &quot;&quot;} in $label&quot;&#10;        &#10;        showNotification(title, text)&#10;        &#10;        // Trigger message processing in the background&#10;        serviceScope.launch {&#10;            // In a real implementation, you would trigger immediate processing&#10;            // of messages from this label&#10;            Log.d(TAG, &quot;Would process new Gmail messages from label $label&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Shows a notification to the user&#10;     */&#10;    private fun showNotification(title: String, text: String) {&#10;        // Create notification channel for Android O and above&#10;        createNotificationChannel()&#10;        &#10;        // Create intent for when notification is tapped&#10;        val intent = Intent(this, MainActivity::class.java).apply {&#10;            addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)&#10;            putExtra(&quot;openBridge&quot;, true)&#10;        }&#10;        &#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_ONE_SHOT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;        &#10;        // Build the notification&#10;        val notificationBuilder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setSmallIcon(R.drawable.ic_launcher_foreground) // Use an appropriate icon&#10;            .setContentTitle(title)&#10;            .setContentText(text)&#10;            .setAutoCancel(true)&#10;            .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION))&#10;            .setContentIntent(pendingIntent)&#10;            .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;        &#10;        // Show the notification&#10;        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        val notificationId = System.currentTimeMillis().toInt()&#10;        notificationManager.notify(notificationId, notificationBuilder.build())&#10;    }&#10;    &#10;    /**&#10;     * Creates the notification channel for Android O and above&#10;     */&#10;    private fun createNotificationChannel() {&#10;        // Create notification channel for Android O and above&#10;        val name = &quot;Message Bridge&quot;&#10;        val description = &quot;Notifications for Telegram and Gmail messages&quot;&#10;        val importance = NotificationManager.IMPORTANCE_HIGH&#10;        &#10;        val channel = NotificationChannel(CHANNEL_ID, name, importance).apply {&#10;            this.description = description&#10;            enableVibration(true)&#10;        }&#10;        &#10;        // Register the channel with the system&#10;        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        notificationManager.createNotificationChannel(channel)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/fcm/FCMTokenManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/fcm/FCMTokenManager.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.bridge.fcm&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.ai.edge.gallery.BuildConfig&#10;import com.google.firebase.messaging.FirebaseMessaging&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.tasks.await&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import org.json.JSONObject&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Manager for handling FCM token registration with the backend server&#10; */&#10;@Singleton&#10;class FCMTokenManager @Inject constructor(&#10;    private val context: Context&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;FCMTokenManager&quot;&#10;        private const val PREFS_NAME = &quot;fcm_token_prefs&quot;&#10;        private const val KEY_FCM_TOKEN = &quot;fcm_token&quot;&#10;        private const val KEY_TOKEN_SENT = &quot;token_sent_to_server&quot;&#10;&#10;        // Replace with your actual backend API URL&#10;        private const val BACKEND_API_URL = &quot;https://your-backend-api.com/register-token&quot;&#10;    }&#10;    &#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    private val client = OkHttpClient.Builder()&#10;        .connectTimeout(30, TimeUnit.SECONDS)&#10;        .readTimeout(30, TimeUnit.SECONDS)&#10;        .writeTimeout(30, TimeUnit.SECONDS)&#10;        .build()&#10;&#10;    /**&#10;     * Gets the current FCM token and registers it with the backend if needed&#10;     */&#10;    suspend fun getAndRegisterFCMToken(): String? {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // Check if we already have a token&#10;                val savedToken = prefs.getString(KEY_FCM_TOKEN, null)&#10;                val tokenSent = prefs.getBoolean(KEY_TOKEN_SENT, false)&#10;                &#10;                if (savedToken != null &amp;&amp; tokenSent) {&#10;                    // Token already sent to server&#10;                    return@withContext savedToken&#10;                }&#10;                &#10;                // Get the current token from Firebase&#10;                val token = FirebaseMessaging.getInstance().token.await()&#10;                &#10;                // Save token locally&#10;                prefs.edit()&#10;                    .putString(KEY_FCM_TOKEN, token)&#10;                    .apply()&#10;                &#10;                // Send token to backend&#10;                val success = sendTokenToBackend(token)&#10;&#10;                if (success) {&#10;                    // Mark as sent&#10;                    prefs.edit()&#10;                        .putBoolean(KEY_TOKEN_SENT, true)&#10;                        .apply()&#10;                    &#10;                    Log.d(TAG, &quot;FCM token registered with backend: $token&quot;)&#10;                } else {&#10;                    Log.e(TAG, &quot;Failed to register FCM token with backend&quot;)&#10;                }&#10;                &#10;                return@withContext token&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error getting FCM token&quot;, e)&#10;                return@withContext null&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sends the FCM token to the backend server&#10;     */&#10;    private suspend fun sendTokenToBackend(token: String): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // In a real app, this would send the token to your backend server&#10;                // For this example, we'll just simulate a successful registration&#10;&#10;                if (BuildConfig.DEBUG) {&#10;                    // In debug mode, just simulate success without actually making the API call&#10;                    Log.d(TAG, &quot;DEBUG MODE: Simulating FCM token registration success&quot;)&#10;                    return@withContext true&#10;                }&#10;&#10;                // Create JSON payload&#10;                val json = JSONObject().apply {&#10;                    put(&quot;token&quot;, token)&#10;                    put(&quot;device_id&quot;, context.getDeviceId())&#10;                    put(&quot;platform&quot;, &quot;android&quot;)&#10;                }&#10;&#10;                // Create request&#10;                val mediaType = &quot;application/json; charset=utf-8&quot;.toMediaType()&#10;                val requestBody = json.toString().toRequestBody(mediaType)&#10;                val request = Request.Builder()&#10;                    .url(BACKEND_API_URL)&#10;                    .post(requestBody)&#10;                    .build()&#10;&#10;                // Execute request&#10;                client.newCall(request).execute().use { response -&gt;&#10;                    return@withContext response.isSuccessful&#10;                }&#10;            } catch (e: IOException) {&#10;                Log.e(TAG, &quot;Error sending FCM token to backend&quot;, e)&#10;                return@withContext false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets a unique device ID for token registration&#10;     */&#10;    private fun Context.getDeviceId(): String {&#10;        val androidId = android.provider.Settings.Secure.getString(&#10;            contentResolver,&#10;            android.provider.Settings.Secure.ANDROID_ID&#10;        )&#10;        return androidId ?: &quot;unknown_device&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.fcm&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.firebase.messaging.FirebaseMessaging&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.tasks.await&#10;import kotlinx.coroutines.withContext&#10;&#10;/**&#10; * Manager for handling FCM token registration with the backend server&#10; */&#10;class FCMTokenManager(private val context: Context) {&#10;    companion object {&#10;        private const val TAG = &quot;FCMTokenManager&quot;&#10;        private const val PREFS_NAME = &quot;fcm_token_prefs&quot;&#10;        private const val KEY_FCM_TOKEN = &quot;fcm_token&quot;&#10;        private const val KEY_TOKEN_SENT = &quot;token_sent_to_server&quot;&#10;    }&#10;    &#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;    /**&#10;     * Gets the current FCM token and registers it with the backend if needed&#10;     */&#10;    suspend fun getAndRegisterFCMToken(): String? {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                // Get the current token from Firebase&#10;                val token = FirebaseMessaging.getInstance().token.await()&#10;                &#10;                // Save token locally&#10;                prefs.edit()&#10;                    .putString(KEY_FCM_TOKEN, token)&#10;                    .putBoolean(KEY_TOKEN_SENT, true)&#10;                    .apply()&#10;                &#10;                Log.d(TAG, &quot;FCM token registered: $token&quot;)&#10;                return@withContext token&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error getting FCM token&quot;, e)&#10;                return@withContext null&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/gmail/GmailMessage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/gmail/GmailMessage.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.gmail&#10;&#10;import java.util.UUID&#10;&#10;/**&#10; * Data class representing a Gmail message&#10; */&#10;data class GmailMessage(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val threadId: String,&#10;    val sender: String,&#10;    val recipients: List&lt;String&gt;,&#10;    val subject: String,&#10;    val body: String,&#10;    val timestamp: Long = System.currentTimeMillis(),&#10;    val hasAttachments: Boolean = false,&#10;    val attachmentUrls: List&lt;String&gt; = emptyList(),&#10;    val labels: List&lt;String&gt; = emptyList()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/gmail/GmailService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/gmail/GmailService.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.gmail&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.ai.edge.gallery.bridge.BridgeMessage&#10;import com.google.ai.edge.gallery.bridge.MessageBridgeRepository&#10;import com.google.ai.edge.gallery.bridge.MessagePlatform&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInAccount&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;import com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential&#10;import com.google.api.client.http.javanet.NetHttpTransport&#10;import com.google.api.client.json.gson.GsonFactory&#10;import com.google.api.client.util.ExponentialBackOff&#10;import com.google.api.services.gmail.Gmail&#10;import com.google.api.services.gmail.GmailScopes&#10;import com.google.api.services.gmail.model.ListMessagesResponse&#10;import com.google.api.services.gmail.model.Message&#10;import com.google.api.services.gmail.model.MessagePart&#10;import com.google.api.services.gmail.model.MessagePartHeader&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import java.io.ByteArrayOutputStream&#10;import java.util.Properties&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;import javax.mail.Session&#10;import javax.mail.internet.InternetAddress&#10;import javax.mail.internet.MimeMessage&#10;&#10;/**&#10; * Service for handling Gmail API interactions&#10; */&#10;@Singleton&#10;class GmailService @Inject constructor(&#10;    @ApplicationContext private val context: Context&#10;) {&#10;    private val TAG = &quot;GmailService&quot;&#10;    private val PREFS_NAME = &quot;gmail_bridge_prefs&quot;&#10;    private val KEY_EMAIL = &quot;gmail_email&quot;&#10;    &#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    private val coroutineScope = CoroutineScope(Dispatchers.IO)&#10;    &#10;    private var gmailService: Gmail? = null&#10;    private var userEmail: String? = null&#10;    &#10;    // Connection state&#10;    private val _connectionState = MutableStateFlow(GmailConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;GmailConnectionState&gt; = _connectionState.asStateFlow()&#10;    &#10;    // Labels&#10;    private val _labels = MutableStateFlow&lt;List&lt;GmailLabel&gt;&gt;(emptyList())&#10;    val labels: StateFlow&lt;List&lt;GmailLabel&gt;&gt; = _labels.asStateFlow()&#10;    &#10;    init {&#10;        // Try to initialize if we have saved email&#10;        userEmail = prefs.getString(KEY_EMAIL, null)&#10;        &#10;        if (!userEmail.isNullOrEmpty()) {&#10;            // Check if we have a valid Google account&#10;            val account = GoogleSignIn.getLastSignedInAccount(context)&#10;            if (account != null &amp;&amp; account.email == userEmail) {&#10;                initializeGmailService(account)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Gets a GoogleSignInOptions object with the required scopes&#10;     */&#10;    fun getGoogleSignInOptions(): GoogleSignInOptions {&#10;        return GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;            .requestEmail()&#10;            .requestScopes(GmailScopes.GMAIL_READONLY, GmailScopes.GMAIL_SEND, GmailScopes.GMAIL_LABELS)&#10;            .build()&#10;    }&#10;    &#10;    /**&#10;     * Initializes the Gmail service with the provided Google account&#10;     */&#10;    fun initializeGmailService(account: GoogleSignInAccount) {&#10;        coroutineScope.launch {&#10;            try {&#10;                _connectionState.value = GmailConnectionState.CONNECTING&#10;                &#10;                userEmail = account.email&#10;                prefs.edit().putString(KEY_EMAIL, userEmail).apply()&#10;                &#10;                // Set up credentials&#10;                val credential = GoogleAccountCredential.usingOAuth2(&#10;                    context,&#10;                    listOf(GmailScopes.GMAIL_READONLY, GmailScopes.GMAIL_SEND, GmailScopes.GMAIL_LABELS)&#10;                ).apply {&#10;                    selectedAccount = account.account&#10;                    backOff = ExponentialBackOff()&#10;                }&#10;                &#10;                // Build the Gmail service&#10;                gmailService = Gmail.Builder(&#10;                    NetHttpTransport(),&#10;                    GsonFactory(),&#10;                    credential&#10;                )&#10;                    .setApplicationName(&quot;AI Chat Bot&quot;)&#10;                    .build()&#10;                &#10;                // Test connection by loading labels&#10;                loadLabels()&#10;                &#10;                _connectionState.value = GmailConnectionState.CONNECTED&#10;                MessageBridgeRepository.updateGmailConnection(true)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error initializing Gmail service&quot;, e)&#10;                _connectionState.value = GmailConnectionState.ERROR&#10;                MessageBridgeRepository.updateGmailConnection(false)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Loads the list of Gmail labels&#10;     */&#10;    private fun loadLabels() {&#10;        coroutineScope.launch {&#10;            try {&#10;                val listLabelsResponse = gmailService?.users()?.labels()?.list(&quot;me&quot;)?.execute()&#10;                val labelsList = listLabelsResponse?.labels?.map { label -&gt;&#10;                    GmailLabel(&#10;                        id = label.id,&#10;                        name = label.name&#10;                    )&#10;                } ?: emptyList()&#10;                &#10;                _labels.value = labelsList&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error loading labels&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Loads recent messages from Gmail&#10;     */&#10;    fun loadRecentMessages(maxResults: Int = 20) {&#10;        coroutineScope.launch {&#10;            try {&#10;                val listMessagesResponse = gmailService?.users()?.messages()?.list(&quot;me&quot;)&#10;                    ?.setMaxResults(maxResults.toLong())&#10;                    ?.execute()&#10;                &#10;                processMessagesResponse(listMessagesResponse)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error loading recent messages&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Loads messages with a specific label&#10;     */&#10;    fun loadMessagesWithLabel(labelId: String, maxResults: Int = 20) {&#10;        coroutineScope.launch {&#10;            try {&#10;                val listMessagesResponse = gmailService?.users()?.messages()?.list(&quot;me&quot;)&#10;                    ?.setLabelIds(listOf(labelId))&#10;                    ?.setMaxResults(maxResults.toLong())&#10;                    ?.execute()&#10;                &#10;                processMessagesResponse(listMessagesResponse)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error loading messages with label&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Processes a list of messages from Gmail API&#10;     */&#10;    private fun processMessagesResponse(response: ListMessagesResponse?) {&#10;        response?.messages?.forEach { messageRef -&gt;&#10;            try {&#10;                val message = gmailService?.users()?.messages()?.get(&quot;me&quot;, messageRef.id)&#10;                    ?.setFormat(&quot;full&quot;)&#10;                    ?.execute()&#10;                &#10;                if (message != null) {&#10;                    val gmailMessage = convertToGmailMessage(message)&#10;                    val bridgeMessage = BridgeMessage.GmailBridgeMessage(&#10;                        id = gmailMessage.id,&#10;                        timestamp = gmailMessage.timestamp,&#10;                        forwarded = false,&#10;                        message = gmailMessage&#10;                    )&#10;                    &#10;                    // Add to recent messages&#10;                    MessageBridgeRepository.addRecentMessage(bridgeMessage)&#10;                    &#10;                    // Check for bridge rules&#10;                    processPotentialBridgeMessage(gmailMessage)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error processing message ${messageRef.id}&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Converts a Gmail API Message to our GmailMessage model&#10;     */&#10;    private fun convertToGmailMessage(message: Message): GmailMessage {&#10;        // Extract headers&#10;        val headers = message.payload.headers&#10;        val subject = headers.find { it.name.equals(&quot;Subject&quot;, ignoreCase = true) }?.value ?: &quot;&quot;&#10;        val from = headers.find { it.name.equals(&quot;From&quot;, ignoreCase = true) }?.value ?: &quot;&quot;&#10;        val to = headers.find { it.name.equals(&quot;To&quot;, ignoreCase = true) }?.value ?: &quot;&quot;&#10;        val recipients = to.split(&quot;,&quot;).map { it.trim() }&#10;        &#10;        // Extract body&#10;        val body = extractMessageBody(message.payload)&#10;        &#10;        // Check for attachments&#10;        val hasAttachments = message.payload.parts?.any { &#10;            it.filename != null &amp;&amp; it.filename.isNotEmpty() &#10;        } ?: false&#10;        &#10;        return GmailMessage(&#10;            id = message.id,&#10;            threadId = message.threadId,&#10;            sender = from,&#10;            recipients = recipients,&#10;            subject = subject,&#10;            body = body,&#10;            timestamp = message.internalDate,&#10;            hasAttachments = hasAttachments,&#10;            labels = message.labelIds ?: emptyList()&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Recursively extracts the text body from a message part&#10;     */&#10;    private fun extractMessageBody(part: MessagePart): String {&#10;        if (part.mimeType == &quot;text/plain&quot; &amp;&amp; part.body.data != null) {&#10;            return String(android.util.Base64.decode(&#10;                part.body.data.replace('-', '+').replace('_', '/'),&#10;                android.util.Base64.DEFAULT&#10;            ))&#10;        }&#10;        &#10;        if (part.parts != null) {&#10;            for (subPart in part.parts) {&#10;                val body = extractMessageBody(subPart)&#10;                if (body.isNotEmpty()) {&#10;                    return body&#10;                }&#10;            }&#10;        }&#10;        &#10;        return &quot;&quot;&#10;    }&#10;    &#10;    /**&#10;     * Processes a Gmail message for potential bridging&#10;     */&#10;    private fun processPotentialBridgeMessage(message: GmailMessage) {&#10;        coroutineScope.launch {&#10;            val rules = MessageBridgeRepository.bridgeRules.value&#10;            &#10;            // Find applicable rules based on labels or sender&#10;            val applicableRules = rules.filter { rule -&gt;&#10;                rule.enabled &amp;&amp;&#10;                rule.sourceType == MessagePlatform.GMAIL &amp;&amp;&#10;                (rule.sourceIdentifier == message.sender || &#10;                 message.labels.contains(rule.sourceIdentifier))&#10;            }&#10;            &#10;            // Process each rule&#10;            applicableRules.forEach { rule -&gt;&#10;                // For now, we'll just log this; in a complete implementation, &#10;                // this would send the message to Telegram&#10;                Log.d(TAG, &quot;Should forward message to Telegram: ${rule.targetIdentifier}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Sends an email&#10;     */&#10;    fun sendEmail(&#10;        to: String,&#10;        subject: String,&#10;        body: String,&#10;        onSuccess: () -&gt; Unit,&#10;        onError: (String) -&gt; Unit&#10;    ) {&#10;        coroutineScope.launch {&#10;            try {&#10;                val props = Properties()&#10;                val session = Session.getDefaultInstance(props, null)&#10;                val email = MimeMessage(session)&#10;                &#10;                email.setFrom(InternetAddress(userEmail))&#10;                email.addRecipient(javax.mail.Message.RecipientType.TO, InternetAddress(to))&#10;                email.subject = subject&#10;                email.setText(body)&#10;                &#10;                val buffer = ByteArrayOutputStream()&#10;                email.writeTo(buffer)&#10;                val bytes = buffer.toByteArray()&#10;                val encodedEmail = android.util.Base64.encodeToString(bytes, android.util.Base64.URL_SAFE)&#10;                &#10;                val message = Message()&#10;                message.raw = encodedEmail&#10;                &#10;                val sentMessage = gmailService?.users()?.messages()?.send(&quot;me&quot;, message)?.execute()&#10;                &#10;                if (sentMessage != null) {&#10;                    Log.d(TAG, &quot;Email sent successfully: ${sentMessage.id}&quot;)&#10;                    onSuccess()&#10;                } else {&#10;                    onError(&quot;Failed to send email: Unknown error&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error sending email&quot;, e)&#10;                onError(&quot;Failed to send email: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Disconnects from Gmail&#10;     */&#10;    fun disconnect() {&#10;        gmailService = null&#10;        userEmail = null&#10;        _connectionState.value = GmailConnectionState.DISCONNECTED&#10;        MessageBridgeRepository.updateGmailConnection(false)&#10;        &#10;        prefs.edit().remove(KEY_EMAIL).apply()&#10;    }&#10;}&#10;&#10;/**&#10; * Enum representing the various Gmail connection states&#10; */&#10;enum class GmailConnectionState {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    CONNECTED,&#10;    ERROR&#10;}&#10;&#10;/**&#10; * Data class representing a Gmail label&#10; */&#10;data class GmailLabel(&#10;    val id: String,&#10;    val name: String&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/permission/BridgePermissionHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/permission/BridgePermissionHelper.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.bridge.permission&#10;&#10;import android.Manifest&#10;import android.app.Activity&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.Uri&#10;import android.os.Build&#10;import android.provider.Settings&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.FragmentActivity&#10;&#10;/**&#10; * Helper class to manage permissions required for the Telegram-Gmail bridge&#10; */&#10;class BridgePermissionHelper(private val activity: FragmentActivity) {&#10;    &#10;    companion object {&#10;        private val REQUIRED_PERMISSIONS = arrayOf(&#10;            Manifest.permission.READ_CONTACTS,&#10;            Manifest.permission.POST_NOTIFICATIONS&#10;        )&#10;        &#10;        /**&#10;         * Checks if all required permissions are granted&#10;         */&#10;        fun hasAllPermissions(context: Context): Boolean {&#10;            return REQUIRED_PERMISSIONS.all {&#10;                ContextCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Single permission launcher&#10;    private val requestPermissionLauncher: ActivityResultLauncher&lt;String&gt; =&#10;        activity.registerForActivityResult(&#10;            ActivityResultContracts.RequestPermission()&#10;        ) { isGranted -&gt;&#10;            // Handle the result&#10;        }&#10;    &#10;    // Multiple permissions launcher&#10;    private val requestMultiplePermissionsLauncher: ActivityResultLauncher&lt;Array&lt;String&gt;&gt; =&#10;        activity.registerForActivityResult(&#10;            ActivityResultContracts.RequestMultiplePermissions()&#10;        ) { permissions -&gt;&#10;            // Handle the result&#10;        }&#10;    &#10;    /**&#10;     * Request all necessary permissions for the bridge feature&#10;     * &#10;     * @return true if all permissions are already granted, false otherwise&#10;     */&#10;    fun requestAllPermissions(): Boolean {&#10;        val missingPermissions = REQUIRED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(activity, it) != PackageManager.PERMISSION_GRANTED&#10;        }.toTypedArray()&#10;        &#10;        if (missingPermissions.isEmpty()) {&#10;            return true&#10;        }&#10;        &#10;        requestMultiplePermissionsLauncher.launch(missingPermissions)&#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Check if we should show the rationale for a specific permission&#10;     */&#10;    fun shouldShowRationale(permission: String): Boolean {&#10;        return ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)&#10;    }&#10;    &#10;    /**&#10;     * Open app settings screen to allow the user to grant permissions manually&#10;     */&#10;    fun openAppSettings() {&#10;        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {&#10;            data = Uri.fromParts(&quot;package&quot;, activity.packageName, null)&#10;            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;        }&#10;        activity.startActivity(intent)&#10;    }&#10;}&#10;&#10;/**&#10; * Composable that handles permission requests for the bridge feature&#10; */&#10;@Composable&#10;fun BridgePermissionsHandler(&#10;    context: Context,&#10;    permissionHelper: BridgePermissionHelper,&#10;    onPermissionsGranted: () -&gt; Unit&#10;) {&#10;    var showRationaleDialog by remember { mutableStateOf(false) }&#10;    var showSettingsDialog by remember { mutableStateOf(false) }&#10;    &#10;    // Check permissions when the composable is first launched&#10;    LaunchedEffect(Unit) {&#10;        if (BridgePermissionHelper.hasAllPermissions(context)) {&#10;            onPermissionsGranted()&#10;        } else {&#10;            val hasPermissions = permissionHelper.requestAllPermissions()&#10;            if (hasPermissions) {&#10;                onPermissionsGranted()&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Rationale dialog&#10;    if (showRationaleDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showRationaleDialog = false },&#10;            title = { Text(&quot;Permissions Required&quot;) },&#10;            text = { Text(&quot;The bridge feature needs access to contacts and notifications to function properly. Please grant these permissions to continue.&quot;) },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showRationaleDialog = false&#10;                        permissionHelper.requestAllPermissions()&#10;                    }&#10;                ) {&#10;                    Text(&quot;Grant Permissions&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showRationaleDialog = false }) {&#10;                    Text(&quot;Not Now&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;    &#10;    // Settings dialog&#10;    if (showSettingsDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSettingsDialog = false },&#10;            title = { Text(&quot;Permissions Required&quot;) },&#10;            text = { Text(&quot;The bridge feature needs access to contacts and notifications. Please enable these permissions in app settings.&quot;) },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showSettingsDialog = false&#10;                        permissionHelper.openAppSettings()&#10;                    }&#10;                ) {&#10;                    Text(&quot;Open Settings&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSettingsDialog = false }) {&#10;                    Text(&quot;Not Now&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.permission&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.Uri&#10;import android.provider.Settings&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.FragmentActivity&#10;&#10;/**&#10; * Helper class to manage permissions required for the Telegram-Gmail bridge&#10; */&#10;class BridgePermissionHelper(private val activity: FragmentActivity) {&#10;    &#10;    companion object {&#10;        private val REQUIRED_PERMISSIONS = arrayOf(&#10;            Manifest.permission.READ_CONTACTS,&#10;            Manifest.permission.POST_NOTIFICATIONS&#10;        )&#10;        &#10;        /**&#10;         * Checks if all required permissions are granted&#10;         */&#10;        fun hasAllPermissions(context: Context): Boolean {&#10;            return REQUIRED_PERMISSIONS.all {&#10;                ContextCompat.checkSelfPermission(context, it) == PackageManager.PERMISSION_GRANTED&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Multiple permissions launcher&#10;    private val requestMultiplePermissionsLauncher: ActivityResultLauncher&lt;Array&lt;String&gt;&gt; =&#10;        activity.registerForActivityResult(&#10;            ActivityResultContracts.RequestMultiplePermissions()&#10;        ) { /* Result handled by caller */ }&#10;    &#10;    /**&#10;     * Request all necessary permissions for the bridge feature&#10;     * &#10;     * @return true if all permissions are already granted, false otherwise&#10;     */&#10;    fun requestAllPermissions(): Boolean {&#10;        val missingPermissions = REQUIRED_PERMISSIONS.filter {&#10;            ContextCompat.checkSelfPermission(activity, it) != PackageManager.PERMISSION_GRANTED&#10;        }.toTypedArray()&#10;        &#10;        if (missingPermissions.isEmpty()) {&#10;            return true&#10;        }&#10;        &#10;        requestMultiplePermissionsLauncher.launch(missingPermissions)&#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Check if we should show the rationale for a specific permission&#10;     */&#10;    fun shouldShowRationale(permission: String): Boolean {&#10;        return ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)&#10;    }&#10;    &#10;    /**&#10;     * Open app settings screen to allow the user to grant permissions manually&#10;     */&#10;    fun openAppSettings() {&#10;        val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {&#10;            data = Uri.fromParts(&quot;package&quot;, activity.packageName, null)&#10;            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;        }&#10;        activity.startActivity(intent)&#10;    }&#10;}&#10;&#10;/**&#10; * Composable that handles permission requests for the bridge feature&#10; */&#10;@Composable&#10;fun BridgePermissionsHandler(&#10;    context: Context,&#10;    permissionHelper: BridgePermissionHelper,&#10;    onPermissionsGranted: () -&gt; Unit&#10;) {&#10;    var showRationaleDialog by remember { mutableStateOf(false) }&#10;    var showSettingsDialog by remember { mutableStateOf(false) }&#10;    &#10;    // Check permissions when the composable is first launched&#10;    LaunchedEffect(Unit) {&#10;        if (BridgePermissionHelper.hasAllPermissions(context)) {&#10;            onPermissionsGranted()&#10;        } else {&#10;            val hasPermissions = permissionHelper.requestAllPermissions()&#10;            if (hasPermissions) {&#10;                onPermissionsGranted()&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Rationale dialog&#10;    if (showRationaleDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showRationaleDialog = false },&#10;            title = { Text(&quot;Permissions Required&quot;) },&#10;            text = { Text(&quot;The bridge feature needs access to contacts and notifications to function properly. Please grant these permissions to continue.&quot;) },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showRationaleDialog = false&#10;                        permissionHelper.requestAllPermissions()&#10;                    }&#10;                ) {&#10;                    Text(&quot;Grant Permissions&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showRationaleDialog = false }) {&#10;                    Text(&quot;Not Now&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;    &#10;    // Settings dialog&#10;    if (showSettingsDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showSettingsDialog = false },&#10;            title = { Text(&quot;Permissions Required&quot;) },&#10;            text = { Text(&quot;The bridge feature needs access to contacts and notifications. Please enable these permissions in app settings.&quot;) },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        showSettingsDialog = false&#10;                        permissionHelper.openAppSettings()&#10;                    }&#10;                ) {&#10;                    Text(&quot;Open Settings&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showSettingsDialog = false }) {&#10;                    Text(&quot;Not Now&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/service/MessageBridgeService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/service/MessageBridgeService.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.service&#10;&#10;import android.app.Service&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.google.ai.edge.gallery.bridge.MessageBridgeRepository&#10;import com.google.ai.edge.gallery.bridge.worker.MessageMonitoringWorker&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.SupervisorJob&#10;import kotlinx.coroutines.cancel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Service that manages the bridge between Telegram and Gmail.&#10; * It schedules the background worker and handles notifications.&#10; */&#10;@AndroidEntryPoint&#10;class MessageBridgeService : Service() {&#10;    companion object {&#10;        private const val TAG = &quot;MessageBridgeService&quot;&#10;        &#10;        /**&#10;         * Starts the bridge service&#10;         */&#10;        fun start(context: Context) {&#10;            context.startService(Intent(context, MessageBridgeService::class.java))&#10;        }&#10;        &#10;        /**&#10;         * Stops the bridge service&#10;         */&#10;        fun stop(context: Context) {&#10;            context.stopService(Intent(context, MessageBridgeService::class.java))&#10;        }&#10;    }&#10;    &#10;    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)&#10;    private var isMonitoring = false&#10;    &#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;MessageBridgeService created&quot;)&#10;        &#10;        // Start observing the bridge rule changes and connection states&#10;        observeBridgeRules()&#10;        observeConnectionStates()&#10;    }&#10;    &#10;    /**&#10;     * Observes changes to bridge rules and updates the worker accordingly&#10;     */&#10;    private fun observeBridgeRules() {&#10;        serviceScope.launch {&#10;            MessageBridgeRepository.bridgeRules.collectLatest { rules -&gt;&#10;                Log.d(TAG, &quot;Bridge rules updated: ${rules.size} rules&quot;)&#10;                &#10;                if (rules.isEmpty()) {&#10;                    // If no rules, cancel the worker&#10;                    if (isMonitoring) {&#10;                        MessageMonitoringWorker.cancel(applicationContext)&#10;                        isMonitoring = false&#10;                    }&#10;                } else if (rules.any { it.enabled }) {&#10;                    // If any enabled rules, ensure worker is scheduled&#10;                    if (!isMonitoring) {&#10;                        MessageMonitoringWorker.schedule(applicationContext)&#10;                        isMonitoring = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Observes connection states for Telegram and Gmail&#10;     */&#10;    private fun observeConnectionStates() {&#10;        serviceScope.launch {&#10;            // Combine Telegram and Gmail connection states&#10;            // If both disconnect, stop monitoring&#10;            &#10;            // For simplicity, we'll just log here, but in a real implementation,&#10;            // you'd use Flow.combine to watch both states simultaneously&#10;            Log.d(TAG, &quot;Started observing connection states&quot;)&#10;        }&#10;    }&#10;    &#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        Log.d(TAG, &quot;MessageBridgeService started&quot;)&#10;        &#10;        // Check if we should start monitoring immediately&#10;        val rules = MessageBridgeRepository.bridgeRules.value&#10;        val telegramConnected = MessageBridgeRepository.telegramConnected.value&#10;        val gmailConnected = MessageBridgeRepository.gmailConnected.value&#10;        &#10;        if (rules.isNotEmpty() &amp;&amp; rules.any { it.enabled } &amp;&amp; (telegramConnected || gmailConnected)) {&#10;            MessageMonitoringWorker.schedule(applicationContext)&#10;            isMonitoring = true&#10;        }&#10;        &#10;        // Return sticky to ensure the service keeps running&#10;        return START_STICKY&#10;    }&#10;    &#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.d(TAG, &quot;MessageBridgeService destroyed&quot;)&#10;        &#10;        // Cancel worker when service is destroyed&#10;        if (isMonitoring) {&#10;            MessageMonitoringWorker.cancel(applicationContext)&#10;        }&#10;        &#10;        // Cancel coroutines&#10;        serviceScope.cancel()&#10;    }&#10;    &#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/telegram/TelegramMessage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/telegram/TelegramMessage.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.telegram&#10;&#10;import java.util.UUID&#10;&#10;/**&#10; * Data class representing a Telegram message&#10; */&#10;data class TelegramMessage(&#10;    val id: String = UUID.randomUUID().toString(),&#10;    val chatId: String,&#10;    val senderId: String,&#10;    val senderName: String,&#10;    val text: String,&#10;    val timestamp: Long = System.currentTimeMillis(),&#10;    val hasAttachments: Boolean = false,&#10;    val attachmentUrls: List&lt;String&gt; = emptyList()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/telegram/TelegramService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/telegram/TelegramService.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.telegram&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import com.google.ai.edge.gallery.bridge.MessageBridgeRepository&#10;import com.google.ai.edge.gallery.bridge.MessagePlatform&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Service for handling Telegram API interactions&#10; * NOTE: Currently disabled due to dependency issues&#10; */&#10;@Singleton&#10;class TelegramService @Inject constructor(&#10;    @ApplicationContext private val context: Context&#10;) {&#10;    private val TAG = &quot;TelegramService&quot;&#10;    private val PREFS_NAME = &quot;telegram_bridge_prefs&quot;&#10;    private val KEY_API_ID = &quot;telegram_api_id&quot;&#10;    private val KEY_API_HASH = &quot;telegram_api_hash&quot;&#10;    private val KEY_PHONE_NUMBER = &quot;telegram_phone_number&quot;&#10;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    private val coroutineScope = CoroutineScope(Dispatchers.IO)&#10;&#10;    // Client and authorization state fields are commented out&#10;    // private var client: Client? = null&#10;    // private var authorizationState: TdApi.AuthorizationState? = null&#10;&#10;    // Connection state&#10;    private val _connectionState = MutableStateFlow(TelegramConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;TelegramConnectionState&gt; = _connectionState.asStateFlow()&#10;&#10;    // Chat list&#10;    private val _chats = MutableStateFlow&lt;List&lt;TelegramChat&gt;&gt;(emptyList())&#10;    val chats: StateFlow&lt;List&lt;TelegramChat&gt;&gt; = _chats.asStateFlow()&#10;&#10;    init {&#10;        // Implementation temporarily disabled&#10;        // Try to initialize if we have saved credentials&#10;        /*&#10;        val apiId = prefs.getInt(KEY_API_ID, 0)&#10;        val apiHash = prefs.getString(KEY_API_HASH, null)&#10;&#10;        if (apiId != 0 &amp;&amp; !apiHash.isNullOrEmpty()) {&#10;            initialize(apiId, apiHash)&#10;        }&#10;        */&#10;    }&#10;&#10;    /**&#10;     * Initializes the Telegram client with API credentials&#10;     * Currently disabled due to dependency issues&#10;     */&#10;    fun initialize(apiId: Int, apiHash: String) {&#10;        // Implementation temporarily disabled&#10;        /*&#10;        // Save credentials&#10;        prefs.edit()&#10;            .putInt(KEY_API_ID, apiId)&#10;            .putString(KEY_API_HASH, apiHash)&#10;            .apply()&#10;&#10;        // Create client&#10;        try {&#10;            _connectionState.value = TelegramConnectionState.CONNECTING&#10;&#10;            // Initialize TDLib native libraries&#10;            Client.execute(TdApi.SetLogVerbosityLevel(2))&#10;&#10;            // Create client&#10;            client = Client.create(object : Client.ResultHandler {&#10;                override fun onResult(result: TdApi.Object) {&#10;                    handleResult(result)&#10;                }&#10;            }, null, null)&#10;&#10;            // Set TDLib parameters&#10;            val parameters = TdApi.TdlibParameters().apply {&#10;                databaseDirectory = context.getDir(&quot;tdlib&quot;, Context.MODE_PRIVATE).absolutePath&#10;                useMessageDatabase = true&#10;                useSecretChats = true&#10;                apiId = apiId&#10;                apiHash = apiHash&#10;                systemLanguageCode = &quot;en&quot;&#10;                deviceModel = &quot;Android&quot;&#10;                applicationVersion = &quot;1.0&quot;&#10;                enableStorageOptimizer = true&#10;            }&#10;&#10;            client?.send(TdApi.SetTdlibParameters(parameters), null)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error initializing Telegram client&quot;, e)&#10;            _connectionState.value = TelegramConnectionState.ERROR&#10;            MessageBridgeRepository.updateTelegramConnection(false)&#10;        }&#10;        */&#10;        &#10;        // Set error state since the functionality is temporarily disabled&#10;        _connectionState.value = TelegramConnectionState.ERROR&#10;        MessageBridgeRepository.updateTelegramConnection(false)&#10;    }&#10;}&#10;&#10;/**&#10; * Enum representing the various Telegram connection states&#10; */&#10;enum class TelegramConnectionState {&#10;    DISCONNECTED,&#10;    CONNECTING,&#10;    WAITING_FOR_PHONE,&#10;    WAITING_FOR_CODE,&#10;    WAITING_FOR_PASSWORD,&#10;    CONNECTED,&#10;    LOGGING_OUT,&#10;    CLOSING,&#10;    ERROR&#10;}&#10;&#10;/**&#10; * Data class representing a Telegram chat&#10; */&#10;data class TelegramChat(&#10;    val id: String,&#10;    val title: String,&#10;    val type: String&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/worker/MessageMonitoringWorker.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/bridge/worker/MessageMonitoringWorker.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.bridge.worker&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.hilt.work.HiltWorker&#10;import androidx.work.Constraints&#10;import androidx.work.CoroutineWorker&#10;import androidx.work.ExistingPeriodicWorkPolicy&#10;import androidx.work.NetworkType&#10;import androidx.work.PeriodicWorkRequestBuilder&#10;import androidx.work.WorkManager&#10;import androidx.work.WorkerParameters&#10;import com.google.ai.edge.gallery.bridge.MessageBridgeRepository&#10;import com.google.ai.edge.gallery.bridge.MessagePlatform&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailService&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramService&#10;import dagger.assisted.Assisted&#10;import dagger.assisted.AssistedInject&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Background worker that periodically checks for new messages in Telegram and Gmail&#10; * and applies bridge rules to forward messages between platforms.&#10; */&#10;@HiltWorker&#10;class MessageMonitoringWorker @AssistedInject constructor(&#10;    @Assisted context: Context,&#10;    @Assisted params: WorkerParameters,&#10;    private val telegramService: TelegramService,&#10;    private val gmailService: GmailService&#10;) : CoroutineWorker(context, params) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MessageMonitoringWorker&quot;&#10;        private const val WORK_NAME = &quot;message_monitoring_worker&quot;&#10;        &#10;        /**&#10;         * Schedules the periodic background work&#10;         */&#10;        fun schedule(context: Context) {&#10;            Log.d(TAG, &quot;Scheduling message monitoring worker&quot;)&#10;            &#10;            val constraints = Constraints.Builder()&#10;                .setRequiredNetworkType(NetworkType.CONNECTED)&#10;                .build()&#10;            &#10;            val workRequest = PeriodicWorkRequestBuilder&lt;MessageMonitoringWorker&gt;(&#10;                15, TimeUnit.MINUTES, // Run every 15 minutes&#10;                5, TimeUnit.MINUTES  // Flex period of 5 minutes&#10;            )&#10;                .setConstraints(constraints)&#10;                .build()&#10;            &#10;            WorkManager.getInstance(context).enqueueUniquePeriodicWork(&#10;                WORK_NAME,&#10;                ExistingPeriodicWorkPolicy.UPDATE, // Replace existing work if it exists&#10;                workRequest&#10;            )&#10;        }&#10;        &#10;        /**&#10;         * Cancels the scheduled background work&#10;         */&#10;        fun cancel(context: Context) {&#10;            Log.d(TAG, &quot;Canceling message monitoring worker&quot;)&#10;            WorkManager.getInstance(context).cancelUniqueWork(WORK_NAME)&#10;        }&#10;    }&#10;    &#10;    override suspend fun doWork(): Result {&#10;        Log.d(TAG, &quot;Message monitoring worker started&quot;)&#10;        &#10;        return try {&#10;            // Check if we have active bridge rules&#10;            val bridgeRules = MessageBridgeRepository.bridgeRules.value&#10;            if (bridgeRules.isEmpty()) {&#10;                Log.d(TAG, &quot;No bridge rules configured, skipping work&quot;)&#10;                return Result.success()&#10;            }&#10;            &#10;            // Check if services are connected&#10;            val telegramConnected = MessageBridgeRepository.telegramConnected.value&#10;            val gmailConnected = MessageBridgeRepository.gmailConnected.value&#10;            &#10;            if (!telegramConnected &amp;&amp; !gmailConnected) {&#10;                Log.d(TAG, &quot;No services connected, skipping work&quot;)&#10;                return Result.success()&#10;            }&#10;            &#10;            // Process Telegram rules if connected&#10;            if (telegramConnected) {&#10;                processTelegramMessages(bridgeRules.filter { &#10;                    it.enabled &amp;&amp; it.sourceType == MessagePlatform.TELEGRAM &#10;                })&#10;            }&#10;            &#10;            // Process Gmail rules if connected&#10;            if (gmailConnected) {&#10;                processGmailMessages(bridgeRules.filter { &#10;                    it.enabled &amp;&amp; it.sourceType == MessagePlatform.GMAIL &#10;                })&#10;            }&#10;            &#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in message monitoring worker&quot;, e)&#10;            Result.retry()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Processes Telegram messages for forwarding to Gmail&#10;     */&#10;    private suspend fun processTelegramMessages(rules: List&lt;com.google.ai.edge.gallery.bridge.BridgeRule&gt;) {&#10;        withContext(Dispatchers.IO) {&#10;            if (rules.isEmpty()) return@withContext&#10;            &#10;            Log.d(TAG, &quot;Processing ${rules.size} Telegram bridge rules&quot;)&#10;            &#10;            // In a real implementation, you would:&#10;            // 1. Fetch recent messages from each chat in the rules&#10;            // 2. Filter for messages newer than last check&#10;            // 3. Forward matching messages to Gmail&#10;            &#10;            // For this example, we'll just log the intent&#10;            rules.forEach { rule -&gt;&#10;                Log.d(TAG, &quot;Would check Telegram chat ${rule.sourceIdentifier} for new messages to forward to ${rule.targetIdentifier}&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Processes Gmail messages for forwarding to Telegram&#10;     */&#10;    private suspend fun processGmailMessages(rules: List&lt;com.google.ai.edge.gallery.bridge.BridgeRule&gt;) {&#10;        withContext(Dispatchers.IO) {&#10;            if (rules.isEmpty()) return@withContext&#10;            &#10;            Log.d(TAG, &quot;Processing ${rules.size} Gmail bridge rules&quot;)&#10;            &#10;            // In a real implementation, you would:&#10;            // 1. Fetch recent messages from each label/sender in the rules&#10;            // 2. Filter for messages newer than last check&#10;            // 3. Forward matching messages to Telegram&#10;            &#10;            // For this example, we'll just log the intent&#10;            rules.forEach { rule -&gt;&#10;                Log.d(TAG, &quot;Would check Gmail ${rule.sourceIdentifier} for new messages to forward to ${rule.targetIdentifier}&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/bridge/MessageBridgeDestination.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/bridge/MessageBridgeDestination.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.bridge&#10;&#10;/**&#10; * Navigation destination for the Message Bridge screen&#10; */&#10;object MessageBridgeDestination {&#10;    const val route = &quot;message_bridge&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/bridge/MessageBridgeDialogs.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/bridge/MessageBridgeDialogs.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.bridge&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.window.DialogProperties&#10;import com.google.ai.edge.gallery.bridge.BridgeRule&#10;import com.google.ai.edge.gallery.bridge.MessagePlatform&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailLabel&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramChat&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramConnectionState&#10;&#10;/**&#10; * Dialog for Telegram authentication&#10; */&#10;@Composable&#10;fun TelegramAuthDialog(&#10;    connectionState: TelegramConnectionState,&#10;    onDismiss: () -&gt; Unit,&#10;    onInitialize: (apiId: Int, apiHash: String) -&gt; Unit,&#10;    onPhoneSubmit: (phoneNumber: String) -&gt; Unit,&#10;    onCodeSubmit: (code: String) -&gt; Unit,&#10;    onPasswordSubmit: (password: String) -&gt; Unit&#10;) {&#10;    var apiId by remember { mutableStateOf(&quot;&quot;) }&#10;    var apiHash by remember { mutableStateOf(&quot;&quot;) }&#10;    var phoneNumber by remember { mutableStateOf(&quot;&quot;) }&#10;    var verificationCode by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    &#10;    Dialog(&#10;        onDismissRequest = onDismiss,&#10;        properties = DialogProperties(dismissOnBackPress = true, dismissOnClickOutside = true)&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            shape = MaterialTheme.shapes.medium&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = &quot;Connect to Telegram&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                when (connectionState) {&#10;                    TelegramConnectionState.DISCONNECTED,&#10;                    TelegramConnectionState.CONNECTING,&#10;                    TelegramConnectionState.ERROR -&gt; {&#10;                        // API credentials entry&#10;                        OutlinedTextField(&#10;                            value = apiId,&#10;                            onValueChange = { apiId = it },&#10;                            label = { Text(&quot;API ID&quot;) },&#10;                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        &#10;                        OutlinedTextField(&#10;                            value = apiHash,&#10;                            onValueChange = { apiHash = it },&#10;                            label = { Text(&quot;API Hash&quot;) },&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        &#10;                        Button(&#10;                            onClick = { &#10;                                onInitialize(apiId.toIntOrNull() ?: 0, apiHash)&#10;                            },&#10;                            enabled = apiId.isNotEmpty() &amp;&amp; apiHash.isNotEmpty(),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            Text(&quot;Initialize&quot;)&#10;                        }&#10;                        &#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        &#10;                        Text(&#10;                            text = &quot;You need to create a Telegram API app to get these credentials. Visit https://my.telegram.org/apps&quot;,&#10;                            style = MaterialTheme.typography.bodySmall&#10;                        )&#10;                    }&#10;                    &#10;                    TelegramConnectionState.WAITING_FOR_PHONE -&gt; {&#10;                        // Phone number entry&#10;                        OutlinedTextField(&#10;                            value = phoneNumber,&#10;                            onValueChange = { phoneNumber = it },&#10;                            label = { Text(&quot;Phone Number (with country code)&quot;) },&#10;                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        &#10;                        Button(&#10;                            onClick = { onPhoneSubmit(phoneNumber) },&#10;                            enabled = phoneNumber.isNotEmpty(),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            Text(&quot;Submit Phone Number&quot;)&#10;                        }&#10;                    }&#10;                    &#10;                    TelegramConnectionState.WAITING_FOR_CODE -&gt; {&#10;                        // Verification code entry&#10;                        OutlinedTextField(&#10;                            value = verificationCode,&#10;                            onValueChange = { verificationCode = it },&#10;                            label = { Text(&quot;Verification Code&quot;) },&#10;                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        &#10;                        Button(&#10;                            onClick = { onCodeSubmit(verificationCode) },&#10;                            enabled = verificationCode.isNotEmpty(),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            Text(&quot;Submit Code&quot;)&#10;                        }&#10;                    }&#10;                    &#10;                    TelegramConnectionState.WAITING_FOR_PASSWORD -&gt; {&#10;                        // 2FA password entry&#10;                        OutlinedTextField(&#10;                            value = password,&#10;                            onValueChange = { password = it },&#10;                            label = { Text(&quot;Two-Factor Authentication Password&quot;) },&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        &#10;                        Button(&#10;                            onClick = { onPasswordSubmit(password) },&#10;                            enabled = password.isNotEmpty(),&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        ) {&#10;                            Text(&quot;Submit Password&quot;)&#10;                        }&#10;                    }&#10;                    &#10;                    else -&gt; {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                TextButton(onClick = onDismiss) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Dialog for adding a new bridge rule&#10; */&#10;@Composable&#10;fun AddBridgeRuleDialog(&#10;    telegramConnected: Boolean,&#10;    gmailConnected: Boolean,&#10;    telegramChats: List&lt;TelegramChat&gt;,&#10;    gmailLabels: List&lt;GmailLabel&gt;,&#10;    onDismiss: () -&gt; Unit,&#10;    onAddRule: (BridgeRule) -&gt; Unit&#10;) {&#10;    var selectedSourceType by remember { mutableStateOf(MessagePlatform.TELEGRAM) }&#10;    var selectedTargetType by remember { mutableStateOf(MessagePlatform.GMAIL) }&#10;    var selectedTelegramChatId by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedGmailLabel by remember { mutableStateOf(&quot;&quot;) }&#10;    var targetEmail by remember { mutableStateOf(&quot;&quot;) }&#10;    &#10;    Dialog(&#10;        onDismissRequest = onDismiss,&#10;        properties = DialogProperties(dismissOnBackPress = true, dismissOnClickOutside = true)&#10;    ) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            shape = MaterialTheme.shapes.medium&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Add Bridge Rule&quot;,&#10;                    style = MaterialTheme.typography.headlineSmall&#10;                )&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                // Source platform selection&#10;                Text(&#10;                    text = &quot;Source Platform&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                &#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    PlatformSelectionButton(&#10;                        platform = MessagePlatform.TELEGRAM,&#10;                        isSelected = selectedSourceType == MessagePlatform.TELEGRAM,&#10;                        enabled = telegramConnected,&#10;                        onClick = { selectedSourceType = MessagePlatform.TELEGRAM }&#10;                    )&#10;                    &#10;                    PlatformSelectionButton(&#10;                        platform = MessagePlatform.GMAIL,&#10;                        isSelected = selectedSourceType == MessagePlatform.GMAIL,&#10;                        enabled = gmailConnected,&#10;                        onClick = { selectedSourceType = MessagePlatform.GMAIL }&#10;                    )&#10;                }&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                // Source identifier selection&#10;                Text(&#10;                    text = &quot;Source ${if (selectedSourceType == MessagePlatform.TELEGRAM) &quot;Chat&quot; else &quot;Label&quot;}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                &#10;                when (selectedSourceType) {&#10;                    MessagePlatform.TELEGRAM -&gt; {&#10;                        if (telegramChats.isEmpty()) {&#10;                            Text(&#10;                                text = &quot;No Telegram chats available&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium&#10;                            )&#10;                        } else {&#10;                            TelegramChatDropdown(&#10;                                chats = telegramChats,&#10;                                selectedChatId = selectedTelegramChatId,&#10;                                onChatSelected = { selectedTelegramChatId = it }&#10;                            )&#10;                        }&#10;                    }&#10;                    MessagePlatform.GMAIL -&gt; {&#10;                        if (gmailLabels.isEmpty()) {&#10;                            Text(&#10;                                text = &quot;No Gmail labels available&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium&#10;                            )&#10;                        } else {&#10;                            GmailLabelDropdown(&#10;                                labels = gmailLabels,&#10;                                selectedLabelId = selectedGmailLabel,&#10;                                onLabelSelected = { selectedGmailLabel = it }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                // Target platform selection&#10;                Text(&#10;                    text = &quot;Target Platform&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                &#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    PlatformSelectionButton(&#10;                        platform = MessagePlatform.TELEGRAM,&#10;                        isSelected = selectedTargetType == MessagePlatform.TELEGRAM,&#10;                        enabled = telegramConnected &amp;&amp; selectedSourceType != MessagePlatform.TELEGRAM,&#10;                        onClick = { selectedTargetType = MessagePlatform.TELEGRAM }&#10;                    )&#10;                    &#10;                    PlatformSelectionButton(&#10;                        platform = MessagePlatform.GMAIL,&#10;                        isSelected = selectedTargetType == MessagePlatform.GMAIL,&#10;                        enabled = gmailConnected &amp;&amp; selectedSourceType != MessagePlatform.GMAIL,&#10;                        onClick = { selectedTargetType = MessagePlatform.GMAIL }&#10;                    )&#10;                }&#10;                &#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                &#10;                // Target identifier selection&#10;                Text(&#10;                    text = &quot;Target ${if (selectedTargetType == MessagePlatform.TELEGRAM) &quot;Chat&quot; else &quot;Email&quot;}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                &#10;                when (selectedTargetType) {&#10;                    MessagePlatform.TELEGRAM -&gt; {&#10;                        if (telegramChats.isEmpty()) {&#10;                            Text(&#10;                                text = &quot;No Telegram chats available&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium&#10;                            )&#10;                        } else {&#10;                            TelegramChatDropdown(&#10;                                chats = telegramChats,&#10;                                selectedChatId = selectedTelegramChatId,&#10;                                onChatSelected = { selectedTelegramChatId = it }&#10;                            )&#10;                        }&#10;                    }&#10;                    MessagePlatform.GMAIL -&gt; {&#10;                        OutlinedTextField(&#10;                            value = targetEmail,&#10;                            onValueChange = { targetEmail = it },&#10;                            label = { Text(&quot;Target Email Address&quot;) },&#10;                            singleLine = true,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(modifier = Modifier.height(24.dp))&#10;                &#10;                // Action buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.End&#10;                ) {&#10;                    TextButton(onClick = onDismiss) {&#10;                        Text(&quot;Cancel&quot;)&#10;                    }&#10;                    &#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    &#10;                    Button(&#10;                        onClick = {&#10;                            val rule = BridgeRule(&#10;                                sourceType = selectedSourceType,&#10;                                targetType = selectedTargetType,&#10;                                sourceIdentifier = when (selectedSourceType) {&#10;                                    MessagePlatform.TELEGRAM -&gt; selectedTelegramChatId&#10;                                    MessagePlatform.GMAIL -&gt; selectedGmailLabel&#10;                                },&#10;                                targetIdentifier = when (selectedTargetType) {&#10;                                    MessagePlatform.TELEGRAM -&gt; selectedTelegramChatId&#10;                                    MessagePlatform.GMAIL -&gt; targetEmail&#10;                                }&#10;                            )&#10;                            onAddRule(rule)&#10;                        },&#10;                        enabled = when {&#10;                            selectedSourceType == MessagePlatform.TELEGRAM &amp;&amp; selectedTelegramChatId.isEmpty() -&gt; false&#10;                            selectedSourceType == MessagePlatform.GMAIL &amp;&amp; selectedGmailLabel.isEmpty() -&gt; false&#10;                            selectedTargetType == MessagePlatform.TELEGRAM &amp;&amp; selectedTelegramChatId.isEmpty() -&gt; false&#10;                            selectedTargetType == MessagePlatform.GMAIL &amp;&amp; targetEmail.isEmpty() -&gt; false&#10;                            else -&gt; true&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Add Rule&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PlatformSelectionButton(&#10;    platform: MessagePlatform,&#10;    isSelected: Boolean,&#10;    enabled: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        enabled = enabled,&#10;        colors = ButtonDefaults.buttonColors(&#10;            containerColor = if (isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.surfaceVariant,&#10;            contentColor = if (isSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurfaceVariant&#10;        ),&#10;        modifier = Modifier.weight(1f)&#10;    ) {&#10;        Text(&#10;            text = when (platform) {&#10;                MessagePlatform.TELEGRAM -&gt; &quot;Telegram&quot;&#10;                MessagePlatform.GMAIL -&gt; &quot;Gmail&quot;&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun TelegramChatDropdown(&#10;    chats: List&lt;TelegramChat&gt;,&#10;    selectedChatId: String,&#10;    onChatSelected: (String) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;    val selectedChat = chats.find { it.id == selectedChatId }&#10;    &#10;    ExposedDropdownMenuBox(&#10;        expanded = expanded,&#10;        onExpandedChange = { expanded = it },&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        OutlinedTextField(&#10;            value = selectedChat?.title ?: &quot;Select a chat&quot;,&#10;            onValueChange = {},&#10;            readOnly = true,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .menuAnchor(),&#10;            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) }&#10;        )&#10;        &#10;        ExposedDropdownMenu(&#10;            expanded = expanded,&#10;            onDismissRequest = { expanded = false }&#10;        ) {&#10;            chats.forEach { chat -&gt;&#10;                DropdownMenuItem(&#10;                    text = { Text(chat.title) },&#10;                    onClick = {&#10;                        onChatSelected(chat.id)&#10;                        expanded = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GmailLabelDropdown(&#10;    labels: List&lt;GmailLabel&gt;,&#10;    selectedLabelId: String,&#10;    onLabelSelected: (String) -&gt; Unit&#10;) {&#10;    var expanded by remember { mutableStateOf(false) }&#10;    val selectedLabel = labels.find { it.id == selectedLabelId }&#10;    &#10;    ExposedDropdownMenuBox(&#10;        expanded = expanded,&#10;        onExpandedChange = { expanded = it },&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        OutlinedTextField(&#10;            value = selectedLabel?.name ?: &quot;Select a label&quot;,&#10;            onValueChange = {},&#10;            readOnly = true,&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .menuAnchor(),&#10;            trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) }&#10;        )&#10;        &#10;        ExposedDropdownMenu(&#10;            expanded = expanded,&#10;            onDismissRequest = { expanded = false }&#10;        ) {&#10;            labels.forEach { label -&gt;&#10;                DropdownMenuItem(&#10;                    text = { Text(label.name) },&#10;                    onClick = {&#10;                        onLabelSelected(label.id)&#10;                        expanded = false&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/bridge/MessageBridgeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/bridge/MessageBridgeScreen.kt" />
              <option name="originalContent" value=")&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BridgeMessageCard(message: BridgeMessage) {&#10;    val dateFormat = remember { SimpleDateFormat(&quot;MMM dd, HH:mm&quot;, Locale.getDefault()) }&#10;&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = when (message.sourceType) {&#10;                MessagePlatform.TELEGRAM -&gt; MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.7f)&#10;                MessagePlatform.GMAIL -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.7f)&#10;            }&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Source indicator&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = when (message.sourceType) {&#10;                            MessagePlatform.TELEGRAM -&gt; Icons.Default.Send&#10;                            MessagePlatform.GMAIL -&gt; Icons.Default.Email&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = when (message.sourceType) {&#10;                            MessagePlatform.TELEGRAM -&gt; MaterialTheme.colorScheme.primary&#10;                            MessagePlatform.GMAIL -&gt; MaterialTheme.colorScheme.secondary&#10;                        }&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;&#10;                    Text(&#10;                        text = when (message.sourceType) {&#10;                            MessagePlatform.TELEGRAM -&gt; &quot;Telegram&quot;&#10;                            MessagePlatform.GMAIL -&gt; &quot;Gmail&quot;&#10;                        },&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;&#10;                // Timestamp&#10;                Text(&#10;                    text = dateFormat.format(Date(message.timestamp)),&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Message content&#10;            when (message) {&#10;                is BridgeMessage.TelegramBridgeMessage -&gt; {&#10;                    Text(&#10;                        text = &quot;${message.message.senderName}: ${message.message.text}&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                }&#10;                is BridgeMessage.GmailBridgeMessage -&gt; {&#10;                    Text(&#10;                        text = &quot;Subject: ${message.message.subject}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                    Text(&#10;                        text = message.message.body,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        maxLines = 3&#10;                    )&#10;                }&#10;            }&#10;&#10;            if (message.forwarded) {&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .background(&#10;                            color = MaterialTheme.colorScheme.surfaceVariant,&#10;                            shape = RoundedCornerShape(4.dp)&#10;                        )&#10;                        .padding(4.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.CheckCircle,&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Forwarded&quot;,&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyStateCard(&#10;    title: String,&#10;    description: String,&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    actionText: String?,&#10;    onAction: (() -&gt; Unit)?&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.7f)&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(48.dp),&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Text(&#10;                text = title,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = description,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            if (actionText != null &amp;&amp; onAction != null) {&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Button(onClick = onAction) {&#10;                    Text(actionText)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;package com.google.ai.edge.gallery.ui.bridge&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.google.ai.edge.gallery.bridge.*&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailConnectionState&#10;import com.google.ai.edge.gallery.bridge.permission.BridgePermissionHelper&#10;import com.google.ai.edge.gallery.bridge.permission.BridgePermissionsHandler&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramConnectionState&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.common.api.ApiException&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;/**&#10; * Main screen for the Telegram-Gmail Bridge feature&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MessageBridgeScreen(&#10;    viewModel: MessageBridgeViewModel = hiltViewModel(),&#10;    navigateUp: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val telegramConnected by viewModel.telegramConnected.collectAsState()&#10;    val gmailConnected by viewModel.gmailConnected.collectAsState()&#10;    val bridgeRules by viewModel.bridgeRules.collectAsState()&#10;    val recentMessages by viewModel.recentMessages.collectAsState()&#10;&#10;    var showTelegramAuthDialog by remember { mutableStateOf(false) }&#10;    var showGmailAuthDialog by remember { mutableStateOf(false) }&#10;    var showAddRuleDialog by remember { mutableStateOf(false) }&#10;&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;            try {&#10;                val account = task.getResult(ApiException::class.java)&#10;                if (account != null) {&#10;                    viewModel.initializeGmail(account)&#10;                }&#10;            } catch (e: ApiException) {&#10;                Log.e(&quot;MessageBridgeScreen&quot;, &quot;Google sign in failed&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Initialize bridge service if needed when screen opens&#10;    LaunchedEffect(Unit) {&#10;        viewModel.initializeBridgeServiceIfNeeded()&#10;    }&#10;    &#10;    // Permission handling&#10;    val activity = LocalContext.current as? FragmentActivity&#10;    if (activity != null) {&#10;        val permissionHelper = remember { BridgePermissionHelper(activity) }&#10;        &#10;        BridgePermissionsHandler(&#10;            context = context,&#10;            permissionHelper = permissionHelper,&#10;            onPermissionsGranted = {&#10;                // Permissions granted, proceed with full functionality&#10;                Log.d(&quot;MessageBridgeScreen&quot;, &quot;All permissions granted&quot;)&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Message Bridge&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = navigateUp) {&#10;                        Icon(Icons.Default.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { showAddRuleDialog = true }) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Add Rule&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Connection Status Cards&#10;            item {&#10;                Text(&#10;                    &quot;Connection Status&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    // Telegram Connection Card&#10;                    ConnectionCard(&#10;                        title = &quot;Telegram&quot;,&#10;                        connected = telegramConnected,&#10;                        icon = Icons.Default.Send,&#10;                        modifier = Modifier.weight(1f),&#10;                        onConnect = { showTelegramAuthDialog = true },&#10;                        onDisconnect = { viewModel.disconnectTelegram() }&#10;                    )&#10;&#10;                    // Gmail Connection Card&#10;                    ConnectionCard(&#10;                        title = &quot;Gmail&quot;,&#10;                        connected = gmailConnected,&#10;                        icon = Icons.Default.Email,&#10;                        modifier = Modifier.weight(1f),&#10;                        onConnect = {&#10;                            val signInIntent = GoogleSignIn.getClient(&#10;                                context,&#10;                                viewModel.getGoogleSignInOptions()&#10;                            ).signInIntent&#10;                            googleSignInLauncher.launch(signInIntent)&#10;                        },&#10;                        onDisconnect = { viewModel.disconnectGmail() }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Bridge Rules&#10;            item {&#10;                Text(&#10;                    &quot;Bridge Rules&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;&#10;            if (bridgeRules.isEmpty()) {&#10;                item {&#10;                    EmptyStateCard(&#10;                        title = &quot;No Bridge Rules&quot;,&#10;                        description = &quot;Add a rule to start forwarding messages between platforms&quot;,&#10;                        icon = Icons.Default.SwapHoriz,&#10;                        actionText = &quot;Add Rule&quot;,&#10;                        onAction = { showAddRuleDialog = true }&#10;                    )&#10;                }&#10;            } else {&#10;                items(bridgeRules) { rule -&gt;&#10;                    BridgeRuleCard(&#10;                        rule = rule,&#10;                        onRemove = { viewModel.removeBridgeRule(rule.id) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Recent Messages&#10;            item {&#10;                Text(&#10;                    &quot;Recent Messages&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;&#10;            if (recentMessages.isEmpty()) {&#10;                item {&#10;                    EmptyStateCard(&#10;                        title = &quot;No Recent Messages&quot;,&#10;                        description = &quot;Messages that pass through the bridge will appear here&quot;,&#10;                        icon = Icons.Default.Message,&#10;                        actionText = null,&#10;                        onAction = null&#10;                    )&#10;                }&#10;            } else {&#10;                items(recentMessages) { message -&gt;&#10;                    BridgeMessageCard(message = message)&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = { viewModel.clearRecentMessages() },&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Icon(Icons.Default.DeleteSweep, contentDescription = null)&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&quot;Clear Message History&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Telegram Authentication Dialog&#10;    if (showTelegramAuthDialog) {&#10;        TelegramAuthDialog(&#10;            connectionState = viewModel.telegramConnectionState.collectAsState().value,&#10;            onDismiss = { showTelegramAuthDialog = false },&#10;            onInitialize = { apiId, apiHash -&gt; viewModel.initializeTelegram(apiId, apiHash) },&#10;            onPhoneSubmit = { phoneNumber -&gt; viewModel.startTelegramAuth(phoneNumber) },&#10;            onCodeSubmit = { code -&gt; viewModel.submitTelegramCode(code) },&#10;            onPasswordSubmit = { password -&gt; viewModel.submitTelegramPassword(password) }&#10;        )&#10;    }&#10;&#10;    // Add Bridge Rule Dialog&#10;    if (showAddRuleDialog) {&#10;        AddBridgeRuleDialog(&#10;            telegramConnected = telegramConnected,&#10;            gmailConnected = gmailConnected,&#10;            telegramChats = viewModel.telegramChats.collectAsState().value,&#10;            gmailLabels = viewModel.gmailLabels.collectAsState().value,&#10;            onDismiss = { showAddRuleDialog = false },&#10;            onAddRule = { rule -&gt;&#10;                val added = viewModel.addBridgeRule(rule)&#10;                if (added) {&#10;                    showAddRuleDialog = false&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConnectionCard(&#10;    title: String,&#10;    connected: Boolean,&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    modifier: Modifier = Modifier,&#10;    onConnect: () -&gt; Unit,&#10;    onDisconnect: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (connected)&#10;                MaterialTheme.colorScheme.primaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                tint = if (connected)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = title,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (connected)&#10;                    MaterialTheme.colorScheme.onPrimaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Text(&#10;                text = if (connected) &quot;Connected&quot; else &quot;Disconnected&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = if (connected)&#10;                    MaterialTheme.colorScheme.onPrimaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Button(&#10;                onClick = if (connected) onDisconnect else onConnect,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = if (connected)&#10;                        MaterialTheme.colorScheme.errorContainer&#10;                    else&#10;                        MaterialTheme.colorScheme.primary&#10;                )&#10;            ) {&#10;                Text(if (connected) &quot;Disconnect&quot; else &quot;Connect&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BridgeRuleCard(&#10;    rule: BridgeRule,&#10;    onRemove: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Source platform&#10;                SourceDestinationLabel(&#10;                    platform = rule.sourceType,&#10;                    identifier = rule.sourceIdentifier,&#10;                    isSource = true,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                // Arrow&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowForward,&#10;                    contentDescription = &quot;to&quot;,&#10;                    tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                // Target platform&#10;                SourceDestinationLabel(&#10;                    platform = rule.targetType,&#10;                    identifier = rule.targetIdentifier,&#10;                    isSource = false,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Switch(&#10;                    checked = rule.enabled,&#10;                    onCheckedChange = { /* TODO: Implement enable/disable */ }&#10;                )&#10;&#10;                IconButton(onClick = onRemove) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Delete,&#10;                        contentDescription = &quot;Delete Rule&quot;,&#10;                        tint = MaterialTheme.colorScheme.error&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SourceDestinationLabel(&#10;    platform: MessagePlatform,&#10;    identifier: String,&#10;    isSource: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = if (isSource) Arrangement.Start else Arrangement.End&#10;    ) {&#10;        if (!isSource) {&#10;            Text(&#10;                text = identifier,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                maxLines = 1&#10;            )&#10;&#10;            Spacer(modifier = Modifier.width(4.dp))&#10;        }&#10;&#10;        Icon(&#10;            imageVector = when (platform) {&#10;                MessagePlatform.TELEGRAM -&gt; Icons.Default.Send&#10;                MessagePlatform.GMAIL -&gt; Icons.Default.Email&#10;            },&#10;            contentDescription = null,&#10;            tint = when (platform) {&#10;                MessagePlatform.TELEGRAM -&gt; MaterialTheme.colorScheme.primary&#10;                MessagePlatform.GMAIL -&gt; MaterialTheme.colorScheme.secondary&#10;            }&#10;        )&#10;&#10;        if (isSource) {&#10;            Spacer(modifier = Modifier.width(4.dp))&#10;&#10;            Text(&#10;                text = identifier,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                maxLines = 1&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.bridge&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.fragment.app.FragmentActivity&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.google.ai.edge.gallery.bridge.*&#10;import com.google.ai.edge.gallery.bridge.gmail.GmailConnectionState&#10;import com.google.ai.edge.gallery.bridge.permission.BridgePermissionHelper&#10;import com.google.ai.edge.gallery.bridge.permission.BridgePermissionsHandler&#10;import com.google.ai.edge.gallery.bridge.telegram.TelegramConnectionState&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.common.api.ApiException&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;/**&#10; * Main screen for the Telegram-Gmail Bridge feature&#10; */&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MessageBridgeScreen(&#10;    viewModel: MessageBridgeViewModel = hiltViewModel(),&#10;    navigateUp: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val telegramConnected by viewModel.telegramConnected.collectAsState()&#10;    val gmailConnected by viewModel.gmailConnected.collectAsState()&#10;    val bridgeRules by viewModel.bridgeRules.collectAsState()&#10;    val recentMessages by viewModel.recentMessages.collectAsState()&#10;&#10;    var showTelegramAuthDialog by remember { mutableStateOf(false) }&#10;    var showGmailAuthDialog by remember { mutableStateOf(false) }&#10;    var showAddRuleDialog by remember { mutableStateOf(false) }&#10;&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;            try {&#10;                val account = task.getResult(ApiException::class.java)&#10;                if (account != null) {&#10;                    viewModel.initializeGmail(account)&#10;                }&#10;            } catch (e: ApiException) {&#10;                Log.e(&quot;MessageBridgeScreen&quot;, &quot;Google sign in failed&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Initialize bridge service if needed when screen opens&#10;    LaunchedEffect(Unit) {&#10;        viewModel.initializeBridgeServiceIfNeeded()&#10;    }&#10;    &#10;    // Permission handling&#10;    val activity = LocalContext.current as? FragmentActivity&#10;    if (activity != null) {&#10;        val permissionHelper = remember { BridgePermissionHelper(activity) }&#10;        &#10;        BridgePermissionsHandler(&#10;            context = context,&#10;            permissionHelper = permissionHelper,&#10;            onPermissionsGranted = {&#10;                // Permissions granted, proceed with full functionality&#10;                Log.d(&quot;MessageBridgeScreen&quot;, &quot;All permissions granted&quot;)&#10;            }&#10;        )&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Message Bridge&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = navigateUp) {&#10;                        Icon(Icons.Default.ArrowBack, contentDescription = &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { showAddRuleDialog = true }) {&#10;                        Icon(Icons.Default.Add, contentDescription = &quot;Add Rule&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        LazyColumn(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(16.dp),&#10;            verticalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Connection Status Cards&#10;            item {&#10;                Text(&#10;                    &quot;Connection Status&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    // Telegram Connection Card&#10;                    ConnectionCard(&#10;                        title = &quot;Telegram&quot;,&#10;                        connected = telegramConnected,&#10;                        icon = Icons.Default.Send,&#10;                        modifier = Modifier.weight(1f),&#10;                        onConnect = { showTelegramAuthDialog = true },&#10;                        onDisconnect = { viewModel.disconnectTelegram() }&#10;                    )&#10;&#10;                    // Gmail Connection Card&#10;                    ConnectionCard(&#10;                        title = &quot;Gmail&quot;,&#10;                        connected = gmailConnected,&#10;                        icon = Icons.Default.Email,&#10;                        modifier = Modifier.weight(1f),&#10;                        onConnect = {&#10;                            val signInIntent = GoogleSignIn.getClient(&#10;                                context,&#10;                                viewModel.getGoogleSignInOptions()&#10;                            ).signInIntent&#10;                            googleSignInLauncher.launch(signInIntent)&#10;                        },&#10;                        onDisconnect = { viewModel.disconnectGmail() }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Bridge Rules&#10;            item {&#10;                Text(&#10;                    &quot;Bridge Rules&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;&#10;            if (bridgeRules.isEmpty()) {&#10;                item {&#10;                    EmptyStateCard(&#10;                        title = &quot;No Bridge Rules&quot;,&#10;                        description = &quot;Add a rule to start forwarding messages between platforms&quot;,&#10;                        icon = Icons.Default.SwapHoriz,&#10;                        actionText = &quot;Add Rule&quot;,&#10;                        onAction = { showAddRuleDialog = true }&#10;                    )&#10;                }&#10;            } else {&#10;                items(bridgeRules) { rule -&gt;&#10;                    BridgeRuleCard(&#10;                        rule = rule,&#10;                        onRemove = { viewModel.removeBridgeRule(rule.id) }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Recent Messages&#10;            item {&#10;                Text(&#10;                    &quot;Recent Messages&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;&#10;            if (recentMessages.isEmpty()) {&#10;                item {&#10;                    EmptyStateCard(&#10;                        title = &quot;No Recent Messages&quot;,&#10;                        description = &quot;Messages that pass through the bridge will appear here&quot;,&#10;                        icon = Icons.Default.Message,&#10;                        actionText = null,&#10;                        onAction = null&#10;                    )&#10;                }&#10;            } else {&#10;                items(recentMessages) { message -&gt;&#10;                    BridgeMessageCard(message = message)&#10;                }&#10;&#10;                item {&#10;                    Button(&#10;                        onClick = { viewModel.clearRecentMessages() },&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Icon(Icons.Default.DeleteSweep, contentDescription = null)&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&quot;Clear Message History&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Telegram Authentication Dialog&#10;    if (showTelegramAuthDialog) {&#10;        TelegramAuthDialog(&#10;            connectionState = viewModel.telegramConnectionState.collectAsState().value,&#10;            onDismiss = { showTelegramAuthDialog = false },&#10;            onInitialize = { apiId, apiHash -&gt; viewModel.initializeTelegram(apiId, apiHash) },&#10;            onPhoneSubmit = { phoneNumber -&gt; viewModel.startTelegramAuth(phoneNumber) },&#10;            onCodeSubmit = { code -&gt; viewModel.submitTelegramCode(code) },&#10;            onPasswordSubmit = { password -&gt; viewModel.submitTelegramPassword(password) }&#10;        )&#10;    }&#10;&#10;    // Add Bridge Rule Dialog&#10;    if (showAddRuleDialog) {&#10;        AddBridgeRuleDialog(&#10;            telegramConnected = telegramConnected,&#10;            gmailConnected = gmailConnected,&#10;            telegramChats = viewModel.telegramChats.collectAsState().value,&#10;            gmailLabels = viewModel.gmailLabels.collectAsState().value,&#10;            onDismiss = { showAddRuleDialog = false },&#10;            onAddRule = { rule -&gt;&#10;                val added = viewModel.addBridgeRule(rule)&#10;                if (added) {&#10;                    showAddRuleDialog = false&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConnectionCard(&#10;    title: String,&#10;    connected: Boolean,&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    modifier: Modifier = Modifier,&#10;    onConnect: () -&gt; Unit,&#10;    onDisconnect: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (connected)&#10;                MaterialTheme.colorScheme.primaryContainer&#10;            else&#10;                MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                tint = if (connected)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = title,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (connected)&#10;                    MaterialTheme.colorScheme.onPrimaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;&#10;            Text(&#10;                text = if (connected) &quot;Connected&quot; else &quot;Disconnected&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = if (connected)&#10;                    MaterialTheme.colorScheme.onPrimaryContainer&#10;                else&#10;                    MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Button(&#10;                onClick = if (connected) onDisconnect else onConnect,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = if (connected)&#10;                        MaterialTheme.colorScheme.errorContainer&#10;                    else&#10;                        MaterialTheme.colorScheme.primary&#10;                )&#10;            ) {&#10;                Text(if (connected) &quot;Disconnect&quot; else &quot;Connect&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BridgeRuleCard(&#10;    rule: BridgeRule,&#10;    onRemove: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Source platform&#10;                SourceDestinationLabel(&#10;                    platform = rule.sourceType,&#10;                    identifier = rule.sourceIdentifier,&#10;                    isSource = true,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;&#10;                // Arrow&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowForward,&#10;                    contentDescription = &quot;to&quot;,&#10;                    tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                // Target platform&#10;                SourceDestinationLabel(&#10;                    platform = rule.targetType,&#10;                    identifier = rule.targetIdentifier,&#10;                    isSource = false,&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Switch(&#10;                    checked = rule.enabled,&#10;                    onCheckedChange = { /* TODO: Implement enable/disable */ }&#10;                )&#10;&#10;                IconButton(onClick = onRemove) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Delete,&#10;                        contentDescription = &quot;Delete Rule&quot;,&#10;                        tint = MaterialTheme.colorScheme.error&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SourceDestinationLabel(&#10;    platform: MessagePlatform,&#10;    identifier: String,&#10;    isSource: Boolean,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = if (isSource) Arrangement.Start else Arrangement.End&#10;    ) {&#10;        if (!isSource) {&#10;            Text(&#10;                text = identifier,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                maxLines = 1&#10;            )&#10;&#10;            Spacer(modifier = Modifier.width(4.dp))&#10;        }&#10;&#10;        Icon(&#10;            imageVector = when (platform) {&#10;                MessagePlatform.TELEGRAM -&gt; Icons.Default.Send&#10;                MessagePlatform.GMAIL -&gt; Icons.Default.Email&#10;            },&#10;            contentDescription = null,&#10;            tint = when (platform) {&#10;                MessagePlatform.TELEGRAM -&gt; MaterialTheme.colorScheme.primary&#10;                MessagePlatform.GMAIL -&gt; MaterialTheme.colorScheme.secondary&#10;            }&#10;        )&#10;&#10;        if (isSource) {&#10;            Spacer(modifier = Modifier.width(4.dp))&#10;&#10;            Text(&#10;                text = identifier,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                maxLines = 1&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun BridgeMessageCard(message: BridgeMessage) {&#10;    val dateFormat = remember { SimpleDateFormat(&quot;MMM dd, HH:mm&quot;, Locale.getDefault()) }&#10;&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = when (message.sourceType) {&#10;                MessagePlatform.TELEGRAM -&gt; MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.7f)&#10;                MessagePlatform.GMAIL -&gt; MaterialTheme.colorScheme.secondaryContainer.copy(alpha = 0.7f)&#10;            }&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Source indicator&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = when (message.sourceType) {&#10;                            MessagePlatform.TELEGRAM -&gt; Icons.Default.Send&#10;                            MessagePlatform.GMAIL -&gt; Icons.Default.Email&#10;                        },&#10;                        contentDescription = null,&#10;                        tint = when (message.sourceType) {&#10;                            MessagePlatform.TELEGRAM -&gt; MaterialTheme.colorScheme.primary&#10;                            MessagePlatform.GMAIL -&gt; MaterialTheme.colorScheme.secondary&#10;                        }&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;&#10;                    Text(&#10;                        text = when (message.sourceType) {&#10;                            MessagePlatform.TELEGRAM -&gt; &quot;Telegram&quot;&#10;                            MessagePlatform.GMAIL -&gt; &quot;Gmail&quot;&#10;                        },&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                }&#10;&#10;                // Timestamp&#10;                Text(&#10;                    text = dateFormat.format(Date(message.timestamp)),&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Message content&#10;            when (message) {&#10;                is BridgeMessage.TelegramBridgeMessage -&gt; {&#10;                    Text(&#10;                        text = &quot;${message.message.senderName}: ${message.message.text}&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                }&#10;                is BridgeMessage.GmailBridgeMessage -&gt; {&#10;                    Text(&#10;                        text = &quot;Subject: ${message.message.subject}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                    Text(&#10;                        text = message.message.body,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        maxLines = 3&#10;                    )&#10;                }&#10;            }&#10;&#10;            if (message.forwarded) {&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .background(&#10;                            color = MaterialTheme.colorScheme.surfaceVariant,&#10;                            shape = RoundedCornerShape(4.dp)&#10;                        )&#10;                        .padding(4.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.CheckCircle,&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.primary&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Forwarded&quot;,&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyStateCard(&#10;    title: String,&#10;    description: String,&#10;    icon: androidx.compose.ui.graphics.vector.ImageVector,&#10;    actionText: String?,&#10;    onAction: (() -&gt; Unit)?&#10;) {&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.7f)&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Icon(&#10;                imageVector = icon,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(48.dp),&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Text(&#10;                text = title,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            Text(&#10;                text = description,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;&#10;            if (actionText != null &amp;&amp; onAction != null) {&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Button(onClick = onAction) {&#10;                    Text(actionText)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/geofence/GeofenceManagementDestination.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/geofence/GeofenceManagementDestination.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.ui.geofence&#10;&#10;import com.google.ai.edge.gallery.ui.navigation.NavigationDestination&#10;&#10;object GeofenceManagementDestination : NavigationDestination {&#10;    override val route = &quot;geofence_management&quot;&#10;    override val destination = &quot;GeofenceManagement&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.geofence&#10;&#10;object GeofenceManagementDestination {&#10;    const val route = &quot;geofence_management&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/geofence/GeofenceManagementViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/geofence/GeofenceManagementViewModel.kt" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.geofence&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.ai.edge.gallery.GeofenceLocation&#10;import com.google.ai.edge.gallery.GeofenceManager&#10;import com.google.ai.edge.gallery.GeofenceRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class GeofenceManagementViewModel @Inject constructor(&#10;    private val geofenceManager: GeofenceManager&#10;) : ViewModel() {&#10;    &#10;    // UI state for the geofence management screen&#10;    private val _uiState = MutableStateFlow&lt;GeofenceManagementUiState&gt;(GeofenceManagementUiState.Loading)&#10;    val uiState: StateFlow&lt;GeofenceManagementUiState&gt; = _uiState.asStateFlow()&#10;    &#10;    init {&#10;        // Collect user geofences from repository&#10;        viewModelScope.launch {&#10;            GeofenceRepository.userGeofences.collectLatest { geofences -&gt;&#10;                _uiState.value = GeofenceManagementUiState.Success(geofences)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Adds a new geofence&#10;     */&#10;    fun addGeofence(geofence: GeofenceLocation) {&#10;        val added = GeofenceRepository.addGeofence(geofence)&#10;        if (added) {&#10;            registerGeofences()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Removes a geofence by ID&#10;     */&#10;    fun removeGeofence(geofenceId: String) {&#10;        val removed = GeofenceRepository.removeGeofence(geofenceId)&#10;        if (removed) {&#10;            registerGeofences()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Registers the current list of geofences with the system&#10;     */&#10;    private fun registerGeofences() {&#10;        viewModelScope.launch {&#10;            geofenceManager.registerGeofences(GeofenceRepository.userGeofences.value)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * UI state for the geofence management screen&#10; */&#10;sealed class GeofenceManagementUiState {&#10;    object Loading : GeofenceManagementUiState()&#10;    data class Success(val geofences: List&lt;GeofenceLocation&gt;) : GeofenceManagementUiState()&#10;    data class Error(val message: String) : GeofenceManagementUiState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/home/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/home/HomeScreen.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.ui.home&#10;&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.provider.OpenableColumns&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.annotation.StringRes&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.GridItemSpan&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.outlined.NoteAdd&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material.icons.filled.SwapHoriz&#10;import androidx.compose.material.icons.rounded.Error&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.ModalBottomSheet&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import com.google.ai.edge.gallery.data.GalleryTopAppBar&#10;import androidx.compose.material3.rememberModalBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.derivedStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalWindowInfo&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import com.google.ai.edge.gallery.R&#10;import com.google.ai.edge.gallery.SignInActivity&#10;import com.google.ai.edge.gallery.data.AppBarAction&#10;import com.google.ai.edge.gallery.data.AppBarActionType&#10;import com.google.ai.edge.gallery.data.Task&#10;import com.google.ai.edge.gallery.proto.ImportedModel&#10;import com.google.ai.edge.gallery.ui.common.TaskIcon&#10;import com.google.ai.edge.gallery.ui.common.getTaskBgColor&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManagerViewModel&#10;import com.google.ai.edge.gallery.ui.theme.customColors&#10;import com.google.ai.edge.gallery.ui.theme.titleMediumNarrow&#10;import com.google.firebase.auth.FirebaseAuth&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;private const val TAG = &quot;AGHomeScreen&quot;&#10;private const val TASK_COUNT_ANIMATION_DURATION = 250&#10;private const val MAX_TASK_CARD_PADDING = 24&#10;private const val MIN_TASK_CARD_PADDING = 18&#10;private const val MAX_TASK_CARD_RADIUS = 43.5&#10;private const val MIN_TASK_CARD_RADIUS = 30&#10;private const val MAX_TASK_CARD_ICON_SIZE = 56&#10;private const val MIN_TASK_CARD_ICON_SIZE = 50&#10;&#10;/** Navigation destination data */&#10;object HomeScreenDestination {&#10;  @StringRes val titleRes = R.string.app_name&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HomeScreen(&#10;  modelManagerViewModel: ModelManagerViewModel,&#10;  navigateToTaskScreen: (Task) -&gt; Unit,&#10;  navigateToGeofenceManagement: () -&gt; Unit,&#10;  navigateToMessageBridge: () -&gt; Unit,&#10;  modifier: Modifier = Modifier,&#10;) {&#10;  val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior()&#10;  val uiState by modelManagerViewModel.uiState.collectAsState()&#10;  var showSettingsDialog by remember { mutableStateOf(false) }&#10;  var showImportModelSheet by remember { mutableStateOf(false) }&#10;  var showUnsupportedFileTypeDialog by remember { mutableStateOf(false) }&#10;  val sheetState = rememberModalBottomSheetState()&#10;  var showImportDialog by remember { mutableStateOf(false) }&#10;  var showImportingDialog by remember { mutableStateOf(false) }&#10;  val selectedLocalModelFileUri = remember { mutableStateOf&lt;Uri?&gt;(null) }&#10;  val selectedImportedModelInfo = remember { mutableStateOf&lt;ImportedModel?&gt;(null) }&#10;  val coroutineScope = rememberCoroutineScope()&#10;  val snackbarHostState = remember { SnackbarHostState() }&#10;  val scope = rememberCoroutineScope()&#10;  val context = LocalContext.current&#10;&#10;  val filePickerLauncher: ActivityResultLauncher&lt;Intent&gt; =&#10;    rememberLauncherForActivityResult(&#10;      contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;      if (result.resultCode == android.app.Activity.RESULT_OK) {&#10;        result.data?.data?.let { uri -&gt;&#10;          val fileName = getFileName(context = context, uri = uri)&#10;          Log.d(TAG, &quot;Selected file: $fileName&quot;)&#10;          if (fileName != null &amp;&amp; !fileName.endsWith(&quot;.task&quot;)) {&#10;            showUnsupportedFileTypeDialog = true&#10;          } else {&#10;            selectedLocalModelFileUri.value = uri&#10;            showImportDialog = true&#10;          }&#10;        } ?: run { Log.d(TAG, &quot;No file selected or URI is null.&quot;) }&#10;      } else {&#10;        Log.d(TAG, &quot;File picking cancelled.&quot;)&#10;      }&#10;    }&#10;&#10;  Scaffold(&#10;    modifier = modifier.nestedScroll(scrollBehavior.nestedScrollConnection),&#10;    topBar = {&#10;      val context = LocalContext.current&#10;&#10;      GalleryTopAppBar(&#10;        title = stringResource(HomeScreenDestination.titleRes),&#10;        rightActions = listOf(&#10;          AppBarAction(&#10;            actionType = AppBarActionType.SIGN_OUT,&#10;            actionFn = {&#10;              FirebaseAuth.getInstance().signOut()&#10;              context.startActivity(&#10;                Intent(context, SignInActivity::class.java).apply {&#10;                  flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                }&#10;              )&#10;            }&#10;          )&#10;        ),&#10;        scrollBehavior = scrollBehavior,&#10;      )&#10;&#10;&#10;&#10;    },&#10;  /*  floatingActionButton = {&#10;      // A floating action button to show &quot;import model&quot; bottom sheet.&#10;      SmallFloatingActionButton(&#10;        onClick = { showImportModelSheet = true },&#10;        containerColor = MaterialTheme.colorScheme.secondaryContainer,&#10;        contentColor = MaterialTheme.colorScheme.secondary,&#10;      ) {&#10;        Icon(Icons.Filled.Add, &quot;&quot;)&#10;      }&#10;    },*/&#10;  ) { innerPadding -&gt;&#10;    Box(contentAlignment = Alignment.BottomCenter, modifier = Modifier.fillMaxSize()) {&#10;      Column(&#10;        modifier = Modifier.fillMaxSize()&#10;      ) {&#10;        // Geofence Management Button&#10;        Card(&#10;          modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            .clickable { navigateToGeofenceManagement() },&#10;          colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;          )&#10;        ) {&#10;          Row(&#10;            modifier = Modifier&#10;              .fillMaxWidth()&#10;              .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;          ) {&#10;            Icon(&#10;              imageVector = Icons.Filled.LocationOn,&#10;              contentDescription = &quot;Geofence&quot;,&#10;              tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Column {&#10;              Text(&#10;                text = &quot;Geofence Management&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;              )&#10;              Text(&#10;                text = &quot;Add and manage location alerts&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;              )&#10;            }&#10;          }&#10;        }&#10;&#10;        // Message Bridge Button&#10;        Card(&#10;          modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            .clickable { navigateToMessageBridge() },&#10;          colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;          )&#10;        ) {&#10;          Row(&#10;            modifier = Modifier&#10;              .fillMaxWidth()&#10;              .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;          ) {&#10;            Icon(&#10;              imageVector = Icons.Filled.SwapHoriz,&#10;              contentDescription = &quot;Message Bridge&quot;,&#10;              tint = MaterialTheme.colorScheme.secondary&#10;            )&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Column {&#10;              Text(&#10;                text = &quot;Telegram-Gmail Bridge&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;              )&#10;              Text(&#10;                text = &quot;Connect and forward messages between platforms&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;              )&#10;            }&#10;          }&#10;        }&#10;&#10;        // Task list&#10;        TaskList(&#10;          tasks = uiState.tasks,&#10;          navigateToTaskScreen = navigateToTaskScreen,&#10;          loadingModelAllowlist = uiState.loadingModelAllowlist,&#10;          modifier = Modifier.weight(1f),&#10;          contentPadding = innerPadding,&#10;        )&#10;      }&#10;&#10;      SnackbarHost(hostState = snackbarHostState, modifier = Modifier.padding(bottom = 32.dp))&#10;    }&#10;  }&#10;&#10;  // Settings dialog.&#10;  if (showSettingsDialog) {&#10;    SettingsDialog(&#10;      curThemeOverride = modelManagerViewModel.readThemeOverride(),&#10;      modelManagerViewModel = modelManagerViewModel,&#10;      onDismissed = { showSettingsDialog = false },&#10;    )&#10;  }&#10;&#10;  // Import model bottom sheet.&#10;  if (showImportModelSheet) {&#10;    ModalBottomSheet(onDismissRequest = { showImportModelSheet = false }, sheetState = sheetState) {&#10;      Text(&#10;        &quot;Import model&quot;,&#10;        style = MaterialTheme.typography.titleLarge,&#10;        modifier = Modifier.padding(vertical = 4.dp, horizontal = 16.dp),&#10;      )&#10;      Box(&#10;        modifier =&#10;          Modifier.clickable {&#10;            coroutineScope.launch {&#10;              // Give it sometime to show the click effect.&#10;              delay(200)&#10;              showImportModelSheet = false&#10;&#10;              // Show file picker.&#10;              val intent =&#10;                Intent(Intent.ACTION_OPEN_DOCUMENT).apply {&#10;                  addCategory(Intent.CATEGORY_OPENABLE)&#10;                  type = &quot;*/*&quot;&#10;                  // Single select.&#10;                  putExtra(Intent.EXTRA_ALLOW_MULTIPLE, false)&#10;                }&#10;              filePickerLauncher.launch(intent)&#10;            }&#10;          }&#10;      ) {&#10;        Row(&#10;          verticalAlignment = Alignment.CenterVertically,&#10;          horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;          modifier = Modifier.fillMaxWidth().padding(16.dp),&#10;        ) {&#10;          Icon(Icons.AutoMirrored.Outlined.NoteAdd, contentDescription = &quot;&quot;)&#10;          Text(&quot;From local model file&quot;)&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  // Import dialog&#10;  if (showImportDialog) {&#10;    selectedLocalModelFileUri.value?.let { uri -&gt;&#10;      ModelImportDialog(&#10;        uri = uri,&#10;        onDismiss = { showImportDialog = false },&#10;        onDone = { info -&gt;&#10;          selectedImportedModelInfo.value = info&#10;          showImportDialog = false&#10;          showImportingDialog = true&#10;        },&#10;      )&#10;    }&#10;  }&#10;&#10;  // Importing in progress dialog.&#10;  if (showImportingDialog) {&#10;    selectedLocalModelFileUri.value?.let { uri -&gt;&#10;      selectedImportedModelInfo.value?.let { info -&gt;&#10;        ModelImportingDialog(&#10;          uri = uri,&#10;          info = info,&#10;          onDismiss = { showImportingDialog = false },&#10;          onDone = {&#10;            modelManagerViewModel.addImportedLlmModel(info = it)&#10;            showImportingDialog = false&#10;&#10;            // Show a snack bar for successful import.&#10;            scope.launch { snackbarHostState.showSnackbar(&quot;Model imported successfully&quot;) }&#10;          },&#10;        )&#10;      }&#10;    }&#10;  }&#10;&#10;  // Alert dialog for unsupported file type.&#10;  if (showUnsupportedFileTypeDialog) {&#10;    AlertDialog(&#10;      onDismissRequest = { showUnsupportedFileTypeDialog = false },&#10;      title = { Text(&quot;Unsupported file type&quot;) },&#10;      text = { Text(&quot;Only \&quot;.task\&quot; file type is supported.&quot;) },&#10;      confirmButton = {&#10;        Button(onClick = { showUnsupportedFileTypeDialog = false }) {&#10;          Text(stringResource(R.string.ok))&#10;        }&#10;      },&#10;    )&#10;  }&#10;&#10;  if (uiState.loadingModelAllowlistError.isNotEmpty()) {&#10;    AlertDialog(&#10;      icon = {&#10;        Icon(Icons.Rounded.Error, contentDescription = &quot;&quot;, tint = MaterialTheme.colorScheme.error)&#10;      },&#10;      title = { Text(uiState.loadingModelAllowlistError) },&#10;      text = { Text(&quot;Please check your internet connection and try again later.&quot;) },&#10;      onDismissRequest = { modelManagerViewModel.loadModelAllowlist() },&#10;      confirmButton = {&#10;        TextButton(onClick = { modelManagerViewModel.loadModelAllowlist() }) { Text(&quot;Retry&quot;) }&#10;      },&#10;    )&#10;  }&#10;}&#10;&#10;@Composable&#10;private fun TaskList(&#10;  tasks: List&lt;Task&gt;,&#10;  navigateToTaskScreen: (Task) -&gt; Unit,&#10;  loadingModelAllowlist: Boolean,&#10;  modifier: Modifier = Modifier,&#10;  contentPadding: PaddingValues = PaddingValues(0.dp),&#10;) {&#10;  val density = LocalDensity.current&#10;  val windowInfo = LocalWindowInfo.current&#10;  val screenWidthDp = remember { with(density) { windowInfo.containerSize.width.toDp() } }&#10;  val screenHeightDp = remember { with(density) { windowInfo.containerSize.height.toDp() } }&#10;  val sizeFraction = remember { ((screenWidthDp - 360.dp) / (410.dp - 360.dp)).coerceIn(0f, 1f) }&#10;  val linkColor = MaterialTheme.customColors.linkColor&#10;&#10;  val introText = buildAnnotatedString {&#10;    append(&quot;Welcome to AI Chat Bot! Explore AI with your amazing thoughts &quot;)&#10;  }&#10;&#10;  Box(modifier = modifier.fillMaxSize()) {&#10;    LazyVerticalGrid(&#10;      columns = GridCells.Fixed(count = 2),&#10;      contentPadding = contentPadding,&#10;      modifier = modifier.padding(12.dp),&#10;      horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;      verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;      // New rel&#10;      item(key = &quot;newReleaseNotification&quot;, span = { GridItemSpan(2) }) { NewReleaseNotification() }&#10;&#10;      // Headline.&#10;      item(key = &quot;headline&quot;, span = { GridItemSpan(2) }) {&#10;        Text(&#10;          introText,&#10;          textAlign = TextAlign.Center,&#10;          style = MaterialTheme.typography.bodyLarge.copy(fontWeight = FontWeight.SemiBold),&#10;          modifier = Modifier.padding(bottom = 20.dp).padding(horizontal = 16.dp),&#10;        )&#10;      }&#10;&#10;      if (loadingModelAllowlist) {&#10;        item(key = &quot;loading&quot;, span = { GridItemSpan(2) }) {&#10;          Row(&#10;            horizontalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxWidth().padding(top = 32.dp),&#10;          ) {&#10;            CircularProgressIndicator(&#10;              trackColor = MaterialTheme.colorScheme.surfaceVariant,&#10;              strokeWidth = 3.dp,&#10;              modifier = Modifier.padding(end = 8.dp).size(20.dp),&#10;            )&#10;            Text(&quot;Loading model list...&quot;, style = MaterialTheme.typography.bodyMedium)&#10;          }&#10;        }&#10;      } else {&#10;        // LLM Cards.&#10;        item(key = &quot;llmCardsHeader&quot;, span = { GridItemSpan(2) }) {&#10;          Text(&#10;            &quot;Select Your Choice&quot;,&#10;            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold),&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.padding(bottom = 4.dp),&#10;          )&#10;        }&#10;&#10;        items(tasks) { task -&gt;&#10;          TaskCard(&#10;            sizeFraction = sizeFraction,&#10;            task = task,&#10;            onClick = { navigateToTaskScreen(task) },&#10;            modifier = Modifier.fillMaxWidth().aspectRatio(1f),&#10;          )&#10;        }&#10;      }&#10;&#10;      // Bottom padding.&#10;      item(key = &quot;bottomPadding&quot;, span = { GridItemSpan(2) }) {&#10;        Spacer(modifier = Modifier.height(60.dp))&#10;      }&#10;    }&#10;&#10;    // Gradient overlay at the bottom.&#10;    Box(&#10;      modifier =&#10;        Modifier.fillMaxWidth()&#10;          .height(screenHeightDp * 0.25f)&#10;          .background(&#10;            Brush.verticalGradient(colors = MaterialTheme.customColors.homeBottomGradient)&#10;          )&#10;          .align(Alignment.BottomCenter)&#10;    )&#10;  }&#10;}&#10;&#10;@Composable&#10;private fun TaskCard(&#10;  task: Task,&#10;  onClick: () -&gt; Unit,&#10;  sizeFraction: Float,&#10;  modifier: Modifier = Modifier,&#10;) {&#10;  val padding =&#10;    (MAX_TASK_CARD_PADDING - MIN_TASK_CARD_PADDING) * sizeFraction + MIN_TASK_CARD_PADDING&#10;  val radius = (MAX_TASK_CARD_RADIUS - MIN_TASK_CARD_RADIUS) * sizeFraction + MIN_TASK_CARD_RADIUS&#10;  val iconSize =&#10;    (MAX_TASK_CARD_ICON_SIZE - MIN_TASK_CARD_ICON_SIZE) * sizeFraction + MIN_TASK_CARD_ICON_SIZE&#10;&#10;  // Observes the model count and updates the model count label with a fade-in/fade-out animation&#10;  // whenever the count changes.&#10;  val modelCount by remember {&#10;    derivedStateOf {&#10;      val trigger = task.updateTrigger.value&#10;      if (trigger &gt;= 0) {&#10;        task.models.size&#10;      } else {&#10;        0&#10;      }&#10;    }&#10;  }&#10;  val modelCountLabel by remember {&#10;    derivedStateOf {&#10;      when (modelCount) {&#10;        1 -&gt; &quot;1 Model&quot;&#10;        else -&gt; &quot;%d Models&quot;.format(modelCount)&#10;      }&#10;    }&#10;  }&#10;  var curModelCountLabel by remember { mutableStateOf(&quot;&quot;) }&#10;  var modelCountLabelVisible by remember { mutableStateOf(true) }&#10;  val modelCountAlpha: Float by&#10;    animateFloatAsState(&#10;      targetValue = if (modelCountLabelVisible) 1f else 0f,&#10;      animationSpec = tween(durationMillis = TASK_COUNT_ANIMATION_DURATION),&#10;    )&#10;  val modelCountScale: Float by&#10;    animateFloatAsState(&#10;      targetValue = if (modelCountLabelVisible) 1f else 0.7f,&#10;      animationSpec = tween(durationMillis = TASK_COUNT_ANIMATION_DURATION),&#10;    )&#10;&#10;  LaunchedEffect(modelCountLabel) {&#10;    if (curModelCountLabel.isEmpty()) {&#10;      curModelCountLabel = modelCountLabel&#10;    } else {&#10;      modelCountLabelVisible = false&#10;      delay(TASK_COUNT_ANIMATION_DURATION.toLong())&#10;      curModelCountLabel = modelCountLabel&#10;      modelCountLabelVisible = true&#10;    }&#10;  }&#10;&#10;  Card(&#10;    modifier = modifier.clip(RoundedCornerShape(radius.dp)).clickable(onClick = onClick),&#10;    colors = CardDefaults.cardColors(containerColor = getTaskBgColor(task = task)),&#10;  ) {&#10;    Column(modifier = Modifier.fillMaxSize().padding(padding.dp)) {&#10;      // Icon.&#10;      TaskIcon(task = task, width = iconSize.dp)&#10;&#10;      Spacer(modifier = Modifier.weight(2f))&#10;&#10;      // Title.&#10;      Text(&#10;        task.type.label,&#10;        color = MaterialTheme.colorScheme.primary,&#10;        style = titleMediumNarrow.copy(fontSize = 20.sp, fontWeight = FontWeight.Bold),&#10;      )&#10;&#10;      Spacer(modifier = Modifier.weight(1f))&#10;&#10;      // Model count.&#10;      Text(&#10;        curModelCountLabel,&#10;        color = MaterialTheme.colorScheme.secondary,&#10;        style = MaterialTheme.typography.bodyMedium,&#10;        modifier = Modifier.alpha(modelCountAlpha).scale(modelCountScale),&#10;      )&#10;    }&#10;  }&#10;}&#10;&#10;// Helper function to get the file name from a URI&#10;fun getFileName(context: Context, uri: Uri): String? {&#10;  if (uri.scheme == &quot;content&quot;) {&#10;    context.contentResolver.query(uri, null, null, null, null)?.use { cursor -&gt;&#10;      if (cursor.moveToFirst()) {&#10;        val nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)&#10;        if (nameIndex != -1) {&#10;          return cursor.getString(nameIndex)&#10;        }&#10;      }&#10;    }&#10;  } else if (uri.scheme == &quot;file&quot;) {&#10;    return uri.lastPathSegment&#10;  }&#10;  return null&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.home&#10;&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.provider.OpenableColumns&#10;import android.util.Log&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.annotation.StringRes&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.GridItemSpan&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.lazy.grid.items&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.outlined.NoteAdd&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material.icons.filled.SwapHoriz&#10;import androidx.compose.material.icons.rounded.Error&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.ModalBottomSheet&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import com.google.ai.edge.gallery.data.GalleryTopAppBar&#10;import androidx.compose.material3.rememberModalBottomSheetState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.derivedStateOf&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.scale&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.input.nestedscroll.nestedScroll&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalWindowInfo&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.text.buildAnnotatedString&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import com.google.ai.edge.gallery.R&#10;import com.google.ai.edge.gallery.SignInActivity&#10;import com.google.ai.edge.gallery.data.AppBarAction&#10;import com.google.ai.edge.gallery.data.AppBarActionType&#10;import com.google.ai.edge.gallery.data.Task&#10;import com.google.ai.edge.gallery.proto.ImportedModel&#10;import com.google.ai.edge.gallery.ui.common.TaskIcon&#10;import com.google.ai.edge.gallery.ui.common.getTaskBgColor&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManagerViewModel&#10;import com.google.ai.edge.gallery.ui.theme.customColors&#10;import com.google.ai.edge.gallery.ui.theme.titleMediumNarrow&#10;import com.google.firebase.auth.FirebaseAuth&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;private const val TAG = &quot;AGHomeScreen&quot;&#10;private const val TASK_COUNT_ANIMATION_DURATION = 250&#10;private const val MAX_TASK_CARD_PADDING = 24&#10;private const val MIN_TASK_CARD_PADDING = 18&#10;private const val MAX_TASK_CARD_RADIUS = 43.5&#10;private const val MIN_TASK_CARD_RADIUS = 30&#10;private const val MAX_TASK_CARD_ICON_SIZE = 56&#10;private const val MIN_TASK_CARD_ICON_SIZE = 50&#10;&#10;/** Navigation destination data */&#10;object HomeScreenDestination {&#10;  @StringRes val titleRes = R.string.app_name&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun HomeScreen(&#10;  modelManagerViewModel: ModelManagerViewModel,&#10;  navigateToTaskScreen: (Task) -&gt; Unit,&#10;  navigateToGeofenceManagement: () -&gt; Unit,&#10;  navigateToMessageBridge: () -&gt; Unit,&#10;  modifier: Modifier = Modifier,&#10;) {&#10;  val scrollBehavior = TopAppBarDefaults.pinnedScrollBehavior()&#10;  val uiState by modelManagerViewModel.uiState.collectAsState()&#10;  var showSettingsDialog by remember { mutableStateOf(false) }&#10;  var showImportModelSheet by remember { mutableStateOf(false) }&#10;  var showUnsupportedFileTypeDialog by remember { mutableStateOf(false) }&#10;  val sheetState = rememberModalBottomSheetState()&#10;  var showImportDialog by remember { mutableStateOf(false) }&#10;  var showImportingDialog by remember { mutableStateOf(false) }&#10;  val selectedLocalModelFileUri = remember { mutableStateOf&lt;Uri?&gt;(null) }&#10;  val selectedImportedModelInfo = remember { mutableStateOf&lt;ImportedModel?&gt;(null) }&#10;  val coroutineScope = rememberCoroutineScope()&#10;  val snackbarHostState = remember { SnackbarHostState() }&#10;  val scope = rememberCoroutineScope()&#10;  val context = LocalContext.current&#10;&#10;  val filePickerLauncher: ActivityResultLauncher&lt;Intent&gt; =&#10;    rememberLauncherForActivityResult(&#10;      contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;      if (result.resultCode == android.app.Activity.RESULT_OK) {&#10;        result.data?.data?.let { uri -&gt;&#10;          val fileName = getFileName(context = context, uri = uri)&#10;          Log.d(TAG, &quot;Selected file: $fileName&quot;)&#10;          if (fileName != null &amp;&amp; !fileName.endsWith(&quot;.task&quot;)) {&#10;            showUnsupportedFileTypeDialog = true&#10;          } else {&#10;            selectedLocalModelFileUri.value = uri&#10;            showImportDialog = true&#10;          }&#10;        } ?: run { Log.d(TAG, &quot;No file selected or URI is null.&quot;) }&#10;      } else {&#10;        Log.d(TAG, &quot;File picking cancelled.&quot;)&#10;      }&#10;    }&#10;&#10;  Scaffold(&#10;    modifier = modifier.nestedScroll(scrollBehavior.nestedScrollConnection),&#10;    topBar = {&#10;      val context = LocalContext.current&#10;&#10;      GalleryTopAppBar(&#10;        title = stringResource(HomeScreenDestination.titleRes),&#10;        rightActions = listOf(&#10;          AppBarAction(&#10;            actionType = AppBarActionType.SIGN_OUT,&#10;            actionFn = {&#10;              FirebaseAuth.getInstance().signOut()&#10;              context.startActivity(&#10;                Intent(context, SignInActivity::class.java).apply {&#10;                  flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                }&#10;              )&#10;            }&#10;          )&#10;        ),&#10;        scrollBehavior = scrollBehavior,&#10;      )&#10;&#10;&#10;&#10;    },&#10;  /*  floatingActionButton = {&#10;      // A floating action button to show &quot;import model&quot; bottom sheet.&#10;      SmallFloatingActionButton(&#10;        onClick = { showImportModelSheet = true },&#10;        containerColor = MaterialTheme.colorScheme.secondaryContainer,&#10;        contentColor = MaterialTheme.colorScheme.secondary,&#10;      ) {&#10;        Icon(Icons.Filled.Add, &quot;&quot;)&#10;      }&#10;    },*/&#10;  ) { innerPadding -&gt;&#10;    Box(contentAlignment = Alignment.BottomCenter, modifier = Modifier.fillMaxSize()) {&#10;      Column(&#10;        modifier = Modifier.fillMaxSize()&#10;      ) {&#10;        // Geofence Management Button&#10;        Card(&#10;          modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            .clickable { navigateToGeofenceManagement() },&#10;          colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;          )&#10;        ) {&#10;          Row(&#10;            modifier = Modifier&#10;              .fillMaxWidth()&#10;              .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;          ) {&#10;            Icon(&#10;              imageVector = Icons.Filled.LocationOn,&#10;              contentDescription = &quot;Geofence&quot;,&#10;              tint = MaterialTheme.colorScheme.primary&#10;            )&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Column {&#10;              Text(&#10;                text = &quot;Geofence Management&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;              )&#10;              Text(&#10;                text = &quot;Add and manage location alerts&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;              )&#10;            }&#10;          }&#10;        }&#10;&#10;        // Message Bridge Button&#10;        Card(&#10;          modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 8.dp)&#10;            .clickable { navigateToMessageBridge() },&#10;          colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.secondaryContainer&#10;          )&#10;        ) {&#10;          Row(&#10;            modifier = Modifier&#10;              .fillMaxWidth()&#10;              .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;          ) {&#10;            Icon(&#10;              imageVector = Icons.Filled.SwapHoriz,&#10;              contentDescription = &quot;Message Bridge&quot;,&#10;              tint = MaterialTheme.colorScheme.secondary&#10;            )&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Column {&#10;              Text(&#10;                text = &quot;Telegram-Gmail Bridge&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;              )&#10;              Text(&#10;                text = &quot;Connect and forward messages between platforms&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;              )&#10;            }&#10;          }&#10;        }&#10;&#10;        // Task list&#10;        TaskList(&#10;          tasks = uiState.tasks,&#10;          navigateToTaskScreen = navigateToTaskScreen,&#10;          loadingModelAllowlist = uiState.loadingModelAllowlist,&#10;          modifier = Modifier.weight(1f),&#10;          contentPadding = innerPadding,&#10;        )&#10;      }&#10;&#10;      SnackbarHost(hostState = snackbarHostState, modifier = Modifier.padding(bottom = 32.dp))&#10;    }&#10;  }&#10;&#10;  // Settings dialog.&#10;  if (showSettingsDialog) {&#10;    SettingsDialog(&#10;      curThemeOverride = modelManagerViewModel.readThemeOverride(),&#10;      modelManagerViewModel = modelManagerViewModel,&#10;      onDismissed = { &#10;        // Using this value to dismiss the dialog&#10;        showSettingsDialog = false &#10;      },&#10;    )&#10;  }&#10;&#10;  // Import model bottom sheet.&#10;  if (showImportModelSheet) {&#10;    ModalBottomSheet(&#10;      onDismissRequest = { &#10;        // Using this value to dismiss the sheet&#10;        showImportModelSheet = false &#10;      }, &#10;      sheetState = sheetState&#10;    ) {&#10;      Text(&#10;        &quot;Import model&quot;,&#10;        style = MaterialTheme.typography.titleLarge,&#10;        modifier = Modifier.padding(vertical = 4.dp, horizontal = 16.dp),&#10;      )&#10;      Box(&#10;        modifier =&#10;          Modifier.clickable {&#10;            coroutineScope.launch {&#10;              // Give it sometime to show the click effect.&#10;              delay(200)&#10;              // Using this value to hide the sheet&#10;              showImportModelSheet = false&#10;&#10;              // Show file picker.&#10;              val intent =&#10;                Intent(Intent.ACTION_OPEN_DOCUMENT).apply {&#10;                  addCategory(Intent.CATEGORY_OPENABLE)&#10;                  type = &quot;*/*&quot;&#10;                  // Single select.&#10;                  putExtra(Intent.EXTRA_ALLOW_MULTIPLE, false)&#10;                }&#10;              filePickerLauncher.launch(intent)&#10;            }&#10;          }&#10;      ) {&#10;        Row(&#10;          verticalAlignment = Alignment.CenterVertically,&#10;          horizontalArrangement = Arrangement.spacedBy(6.dp),&#10;          modifier = Modifier.fillMaxWidth().padding(16.dp),&#10;        ) {&#10;          Icon(Icons.AutoMirrored.Outlined.NoteAdd, contentDescription = &quot;&quot;)&#10;          Text(&quot;From local model file&quot;)&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  // Import dialog&#10;  if (showImportDialog) {&#10;    selectedLocalModelFileUri.value?.let { uri -&gt;&#10;      ModelImportDialog(&#10;        uri = uri,&#10;        onDismiss = { &#10;          // Using this value to dismiss the dialog&#10;          showImportDialog = false &#10;        },&#10;        onDone = { info -&gt;&#10;          selectedImportedModelInfo.value = info&#10;          // Using this value to hide the dialog&#10;          showImportDialog = false&#10;          showImportingDialog = true&#10;        },&#10;      )&#10;    }&#10;  }&#10;&#10;  // Importing in progress dialog.&#10;  if (showImportingDialog) {&#10;    selectedLocalModelFileUri.value?.let { uri -&gt;&#10;      selectedImportedModelInfo.value?.let { info -&gt;&#10;        ModelImportingDialog(&#10;          uri = uri,&#10;          info = info,&#10;          onDismiss = { &#10;            // Using this value to dismiss the dialog&#10;            showImportingDialog = false &#10;          },&#10;          onDone = {&#10;            modelManagerViewModel.addImportedLlmModel(info = it)&#10;            // Using this value to hide the dialog&#10;            showImportingDialog = false&#10;&#10;            // Show a snack bar for successful import.&#10;            scope.launch { snackbarHostState.showSnackbar(&quot;Model imported successfully&quot;) }&#10;          },&#10;        )&#10;      }&#10;    }&#10;  }&#10;&#10;  // Alert dialog for unsupported file type.&#10;  if (showUnsupportedFileTypeDialog) {&#10;    AlertDialog(&#10;      onDismissRequest = { &#10;        // Using this value to dismiss the dialog&#10;        showUnsupportedFileTypeDialog = false &#10;      },&#10;      title = { Text(&quot;Unsupported file type&quot;) },&#10;      text = { Text(&quot;Only \&quot;.task\&quot; file type is supported.&quot;) },&#10;      confirmButton = {&#10;        Button(onClick = { &#10;          // Using this value to dismiss the dialog&#10;          showUnsupportedFileTypeDialog = false &#10;        }) {&#10;          Text(stringResource(R.string.ok))&#10;        }&#10;      },&#10;    )&#10;  }&#10;&#10;  if (uiState.loadingModelAllowlistError.isNotEmpty()) {&#10;    AlertDialog(&#10;      icon = {&#10;        Icon(Icons.Rounded.Error, contentDescription = &quot;&quot;, tint = MaterialTheme.colorScheme.error)&#10;      },&#10;      title = { Text(uiState.loadingModelAllowlistError) },&#10;      text = { Text(&quot;Please check your internet connection and try again later.&quot;) },&#10;      onDismissRequest = { modelManagerViewModel.loadModelAllowlist() },&#10;      confirmButton = {&#10;        TextButton(onClick = { modelManagerViewModel.loadModelAllowlist() }) { Text(&quot;Retry&quot;) }&#10;      },&#10;    )&#10;  }&#10;}&#10;&#10;@Composable&#10;private fun TaskList(&#10;  tasks: List&lt;Task&gt;,&#10;  navigateToTaskScreen: (Task) -&gt; Unit,&#10;  loadingModelAllowlist: Boolean,&#10;  modifier: Modifier = Modifier,&#10;  contentPadding: PaddingValues = PaddingValues(0.dp),&#10;) {&#10;  val density = LocalDensity.current&#10;  val windowInfo = LocalWindowInfo.current&#10;  val screenWidthDp = remember { with(density) { windowInfo.containerSize.width.toDp() } }&#10;  val screenHeightDp = remember { with(density) { windowInfo.containerSize.height.toDp() } }&#10;  val sizeFraction = remember { ((screenWidthDp - 360.dp) / (410.dp - 360.dp)).coerceIn(0f, 1f) }&#10;  // Removing unused variable&#10;  // val linkColor = MaterialTheme.customColors.linkColor&#10;&#10;  val introText = buildAnnotatedString {&#10;    append(&quot;Welcome to AI Chat Bot! Explore AI with your amazing thoughts &quot;)&#10;  }&#10;&#10;  Box(modifier = modifier.fillMaxSize()) {&#10;    LazyVerticalGrid(&#10;      columns = GridCells.Fixed(count = 2),&#10;      contentPadding = contentPadding,&#10;      modifier = modifier.padding(12.dp),&#10;      horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;      verticalArrangement = Arrangement.spacedBy(8.dp),&#10;    ) {&#10;      // New rel&#10;      item(key = &quot;newReleaseNotification&quot;, span = { GridItemSpan(2) }) { NewReleaseNotification() }&#10;&#10;      // Headline.&#10;      item(key = &quot;headline&quot;, span = { GridItemSpan(2) }) {&#10;        Text(&#10;          introText,&#10;          textAlign = TextAlign.Center,&#10;          style = MaterialTheme.typography.bodyLarge.copy(fontWeight = FontWeight.SemiBold),&#10;          modifier = Modifier.padding(bottom = 20.dp).padding(horizontal = 16.dp),&#10;        )&#10;      }&#10;&#10;      if (loadingModelAllowlist) {&#10;        item(key = &quot;loading&quot;, span = { GridItemSpan(2) }) {&#10;          Row(&#10;            horizontalArrangement = Arrangement.Center,&#10;            modifier = Modifier.fillMaxWidth().padding(top = 32.dp),&#10;          ) {&#10;            CircularProgressIndicator(&#10;              trackColor = MaterialTheme.colorScheme.surfaceVariant,&#10;              strokeWidth = 3.dp,&#10;              modifier = Modifier.padding(end = 8.dp).size(20.dp),&#10;            )&#10;            Text(&quot;Loading model list...&quot;, style = MaterialTheme.typography.bodyMedium)&#10;          }&#10;        }&#10;      } else {&#10;        // LLM Cards.&#10;        item(key = &quot;llmCardsHeader&quot;, span = { GridItemSpan(2) }) {&#10;          Text(&#10;            &quot;Select Your Choice&quot;,&#10;            style = MaterialTheme.typography.titleSmall.copy(fontWeight = FontWeight.SemiBold),&#10;            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;            modifier = Modifier.padding(bottom = 4.dp),&#10;          )&#10;        }&#10;&#10;        items(tasks) { task -&gt;&#10;          TaskCard(&#10;            sizeFraction = sizeFraction,&#10;            task = task,&#10;            onClick = { navigateToTaskScreen(task) },&#10;            modifier = Modifier.fillMaxWidth().aspectRatio(1f),&#10;          )&#10;        }&#10;      }&#10;&#10;      // Bottom padding.&#10;      item(key = &quot;bottomPadding&quot;, span = { GridItemSpan(2) }) {&#10;        Spacer(modifier = Modifier.height(60.dp))&#10;      }&#10;    }&#10;&#10;    // Gradient overlay at the bottom.&#10;    Box(&#10;      modifier =&#10;        Modifier.fillMaxWidth()&#10;          .height(screenHeightDp * 0.25f)&#10;          .background(&#10;            Brush.verticalGradient(colors = MaterialTheme.customColors.homeBottomGradient)&#10;          )&#10;          .align(Alignment.BottomCenter)&#10;    )&#10;  }&#10;}&#10;&#10;@Composable&#10;private fun TaskCard(&#10;  task: Task,&#10;  onClick: () -&gt; Unit,&#10;  sizeFraction: Float,&#10;  modifier: Modifier = Modifier,&#10;) {&#10;  val padding =&#10;    (MAX_TASK_CARD_PADDING - MIN_TASK_CARD_PADDING) * sizeFraction + MIN_TASK_CARD_PADDING&#10;  val radius = (MAX_TASK_CARD_RADIUS - MIN_TASK_CARD_RADIUS) * sizeFraction + MIN_TASK_CARD_RADIUS&#10;  val iconSize =&#10;    (MAX_TASK_CARD_ICON_SIZE - MIN_TASK_CARD_ICON_SIZE) * sizeFraction + MIN_TASK_CARD_ICON_SIZE&#10;&#10;  // Observes the model count and updates the model count label with a fade-in/fade-out animation&#10;  // whenever the count changes.&#10;  val modelCount by remember {&#10;    derivedStateOf {&#10;      val trigger = task.updateTrigger.value&#10;      if (trigger &gt;= 0) {&#10;        task.models.size&#10;      } else {&#10;        0&#10;      }&#10;    }&#10;  }&#10;  val modelCountLabel by remember {&#10;    derivedStateOf {&#10;      when (modelCount) {&#10;        1 -&gt; &quot;1 Model&quot;&#10;        else -&gt; &quot;%d Models&quot;.format(modelCount)&#10;      }&#10;    }&#10;  }&#10;  var curModelCountLabel by remember { mutableStateOf(&quot;&quot;) }&#10;  var modelCountLabelVisible by remember { mutableStateOf(true) }&#10;  val modelCountAlpha: Float by&#10;    animateFloatAsState(&#10;      targetValue = if (modelCountLabelVisible) 1f else 0f,&#10;      animationSpec = tween(durationMillis = TASK_COUNT_ANIMATION_DURATION),&#10;    )&#10;  val modelCountScale: Float by&#10;    animateFloatAsState(&#10;      targetValue = if (modelCountLabelVisible) 1f else 0.7f,&#10;      animationSpec = tween(durationMillis = TASK_COUNT_ANIMATION_DURATION),&#10;    )&#10;&#10;  LaunchedEffect(modelCountLabel) {&#10;    if (curModelCountLabel.isEmpty()) {&#10;      curModelCountLabel = modelCountLabel&#10;    } else {&#10;      // This state value is used by the animation system&#10;      @Suppress(&quot;UNUSED_VALUE&quot;)&#10;      modelCountLabelVisible = false&#10;      delay(TASK_COUNT_ANIMATION_DURATION.toLong())&#10;      curModelCountLabel = modelCountLabel&#10;      // This state value is used by the animation system&#10;      @Suppress(&quot;UNUSED_VALUE&quot;)&#10;      modelCountLabelVisible = true&#10;    }&#10;  }&#10;&#10;  Card(&#10;    modifier = modifier.clip(RoundedCornerShape(radius.dp)).clickable(onClick = onClick),&#10;    colors = CardDefaults.cardColors(containerColor = getTaskBgColor(task = task)),&#10;  ) {&#10;    Column(modifier = Modifier.fillMaxSize().padding(padding.dp)) {&#10;      // Icon.&#10;      TaskIcon(task = task, width = iconSize.dp)&#10;&#10;      Spacer(modifier = Modifier.weight(2f))&#10;&#10;      // Title.&#10;      Text(&#10;        task.type.label,&#10;        color = MaterialTheme.colorScheme.primary,&#10;        style = titleMediumNarrow.copy(fontSize = 20.sp, fontWeight = FontWeight.Bold),&#10;      )&#10;&#10;      Spacer(modifier = Modifier.weight(1f))&#10;&#10;      // Model count.&#10;      Text(&#10;        curModelCountLabel,&#10;        color = MaterialTheme.colorScheme.secondary,&#10;        style = MaterialTheme.typography.bodyMedium,&#10;        modifier = Modifier.alpha(modelCountAlpha).scale(modelCountScale),&#10;      )&#10;    }&#10;  }&#10;}&#10;&#10;// Helper function to get the file name from a URI&#10;fun getFileName(context: Context, uri: Uri): String? {&#10;  if (uri.scheme == &quot;content&quot;) {&#10;    context.contentResolver.query(uri, null, null, null, null)?.use { cursor -&gt;&#10;      if (cursor.moveToFirst()) {&#10;        val nameIndex = cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)&#10;        if (nameIndex != -1) {&#10;          return cursor.getString(nameIndex)&#10;        }&#10;      }&#10;    }&#10;  } else if (uri.scheme == &quot;file&quot;) {&#10;    return uri.lastPathSegment&#10;  }&#10;  return null&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/navigation/GalleryNavGraph.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/navigation/GalleryNavGraph.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.ui.navigation&#10;import android.util.Log&#10;import androidx.compose.animation.AnimatedContentTransitionScope&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.EnterTransition&#10;import androidx.compose.animation.ExitTransition&#10;import androidx.compose.animation.core.EaseOutExpo&#10;import androidx.compose.animation.core.FiniteAnimationSpec&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.zIndex&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import androidx.navigation.NavBackStackEntry&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navArgument&#10;import com.google.ai.edge.gallery.data.Model&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_AUDIO&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_IMAGE&#10;import com.google.ai.edge.gallery.data.TASK_LLM_CHAT&#10;import com.google.ai.edge.gallery.data.TASK_LLM_PROMPT_LAB&#10;import com.google.ai.edge.gallery.data.Task&#10;import com.google.ai.edge.gallery.data.TaskType&#10;import com.google.ai.edge.gallery.data.getModelByName&#10;import com.google.ai.edge.gallery.AuthViewModel&#10;import com.google.ai.edge.gallery.ui.auth.SignInScreen&#10;import com.google.ai.edge.gallery.SignUpScreen&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.content.Intent&#10;import com.google.ai.edge.gallery.SignInActivity&#10;import com.google.ai.edge.gallery.ui.home.HomeScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatViewModel&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnDestination&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnScreen&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnViewModel&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManager&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManagerViewModel&#10;import com.google.ai.edge.gallery.ui.geofence.GeofenceManagementDestination&#10;import com.google.ai.edge.gallery.ui.geofence.GeofenceManagementScreen&#10;&#10;// Auth screen routes&#10;object SignInDestination {&#10;  const val route = &quot;sign_in&quot;&#10;}&#10;&#10;object SignUpDestination {&#10;  const val route = &quot;sign_up&quot;&#10;}&#10;&#10;private const val TAG = &quot;AGGalleryNavGraph&quot;&#10;private const val ROUTE_PLACEHOLDER = &quot;placeholder&quot;&#10;private const val ENTER_ANIMATION_DURATION_MS = 500&#10;private val ENTER_ANIMATION_EASING = EaseOutExpo&#10;private const val ENTER_ANIMATION_DELAY_MS = 100&#10;&#10;private const val EXIT_ANIMATION_DURATION_MS = 500&#10;private val EXIT_ANIMATION_EASING = EaseOutExpo&#10;&#10;private fun enterTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(&#10;    ENTER_ANIMATION_DURATION_MS,&#10;    easing = ENTER_ANIMATION_EASING,&#10;    delayMillis = ENTER_ANIMATION_DELAY_MS,&#10;  )&#10;}&#10;&#10;private fun exitTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(EXIT_ANIMATION_DURATION_MS, easing = EXIT_ANIMATION_EASING)&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideEnter(): EnterTransition {&#10;  return slideIntoContainer(&#10;    animationSpec = enterTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Left,&#10;  )&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideExit(): ExitTransition {&#10;  return slideOutOfContainer(&#10;    animationSpec = exitTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Right,&#10;  )&#10;}&#10;&#10;/** Navigation routes. */&#10;@Composable&#10;fun GalleryNavHost(&#10;  navController: NavHostController,&#10;  modifier: Modifier = Modifier,&#10;  modelManagerViewModel: ModelManagerViewModel = hiltViewModel(),&#10;) {&#10;  val lifecycleOwner = LocalLifecycleOwner.current&#10;  var showModelManager by remember { mutableStateOf(false) }&#10;  var pickedTask by remember { mutableStateOf&lt;Task?&gt;(null) }&#10;&#10;  // Track whether app is in foreground.&#10;  DisposableEffect(lifecycleOwner) {&#10;    val observer = LifecycleEventObserver { _, event -&gt;&#10;      when (event) {&#10;        Lifecycle.Event.ON_START,&#10;        Lifecycle.Event.ON_RESUME -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = true)&#10;        }&#10;        Lifecycle.Event.ON_STOP,&#10;        Lifecycle.Event.ON_PAUSE -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = false)&#10;        }&#10;        else -&gt; {&#10;          /* Do nothing for other events */&#10;        }&#10;      }&#10;    }&#10;&#10;    lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;    onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }&#10;  }&#10;&#10;  HomeScreen(&#10;    modelManagerViewModel = modelManagerViewModel,&#10;    navigateToTaskScreen = { task -&gt;&#10;      pickedTask = task&#10;      showModelManager = true&#10;    },&#10;    navigateToGeofenceManagement = {&#10;      navController.navigate(GeofenceManagementDestination.route)&#10;    }&#10;  )&#10;&#10;  // Model manager.&#10;  AnimatedVisibility(&#10;    visible = showModelManager,&#10;    enter = slideInHorizontally(initialOffsetX = { it }),&#10;    exit = slideOutHorizontally(targetOffsetX = { it }),&#10;  ) {&#10;    val curPickedTask = pickedTask&#10;    if (curPickedTask != null) {&#10;      ModelManager(&#10;        viewModel = modelManagerViewModel,&#10;        task = curPickedTask,&#10;        onModelClicked = { model -&gt;&#10;          navigateToTaskScreen(&#10;            navController = navController,&#10;            taskType = curPickedTask.type,&#10;            model = model,&#10;          )&#10;        },&#10;        navigateUp = { showModelManager = false },&#10;      )&#10;    }&#10;  }&#10;&#10;  NavHost(&#10;    navController = navController,&#10;    // Default to open home screen.&#10;    startDestination = ROUTE_PLACEHOLDER,&#10;    enterTransition = { EnterTransition.None },&#10;    exitTransition = { ExitTransition.None },&#10;    modifier = modifier.zIndex(1f),&#10;  ) {&#10;    // Placeholder root screen&#10;    composable(route = ROUTE_PLACEHOLDER) { Text(&quot;&quot;) }&#10;&#10;    // Auth screens&#10;    composable(route = SignInDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      val context = LocalContext.current&#10;      SignInScreen(&#10;        onGoogleSignInClick = {&#10;            // Launch SignInActivity to handle Google sign-in flow and Firebase auth&#10;            context.startActivity(Intent(context, SignInActivity::class.java))&#10;        },&#10;        onEmailSignInClick = { email, password -&gt;&#10;            authViewModel.signInWithEmailAndPassword(email, password)&#10;        },&#10;        onSignUpClick = {&#10;            navController.navigate(SignUpDestination.route)&#10;        }&#10;      )&#10;    }&#10;&#10;    composable(route = SignUpDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      SignUpScreen(&#10;        navController = navController,&#10;        authViewModel = authViewModel&#10;      )&#10;    }&#10;&#10;    // LLM chat demos.&#10;    composable(&#10;      route = &quot;${LlmChatDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmChatViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_CHAT)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmChatScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // LLM single turn.&#10;    composable(&#10;      route = &quot;${LlmSingleTurnDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmSingleTurnViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_PROMPT_LAB)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmSingleTurnScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask image.&#10;    composable(&#10;      route = &quot;${LlmAskImageDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskImageViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_IMAGE)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskImageScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask audio.&#10;    composable(&#10;      route = &quot;${LlmAskAudioDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskAudioViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_AUDIO)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskAudioScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Geofence management.&#10;    composable(&#10;      route = GeofenceManagementDestination.route,&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) {&#10;      GeofenceManagementScreen(&#10;        navigateUp = { navController.navigateUp() },&#10;      )&#10;    }&#10;  }&#10;&#10;  // Handle incoming intents for deep links&#10;  val intent = androidx.activity.compose.LocalActivity.current?.intent&#10;  val data = intent?.data&#10;  if (data != null) {&#10;    intent.data = null&#10;    Log.d(TAG, &quot;navigation link clicked: $data&quot;)&#10;    if (data.toString().startsWith(&quot;com.google.ai.edge.gallery://model/&quot;)) {&#10;      val modelName = data.pathSegments.last()&#10;      getModelByName(modelName)?.let { model -&gt;&#10;        // TODO(jingjin): need to show a list of possible tasks for this model.&#10;        navigateToTaskScreen(&#10;          navController = navController,&#10;          taskType = TaskType.LLM_CHAT,&#10;          model = model,&#10;        )&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;fun navigateToTaskScreen(&#10;  navController: NavHostController,&#10;  taskType: TaskType,&#10;  model: Model? = null,&#10;) {&#10;  val modelName = model?.name ?: &quot;&quot;&#10;  when (taskType) {&#10;    TaskType.LLM_CHAT -&gt; navController.navigate(&quot;${LlmChatDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_IMAGE -&gt; navController.navigate(&quot;${LlmAskImageDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_AUDIO -&gt; navController.navigate(&quot;${LlmAskAudioDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_PROMPT_LAB -&gt;&#10;      navController.navigate(&quot;${LlmSingleTurnDestination.route}/${modelName}&quot;)&#10;    TaskType.TEST_TASK_1 -&gt; {}&#10;    TaskType.TEST_TASK_2 -&gt; {}&#10;  }&#10;}&#10;&#10;fun getModelFromNavigationParam(entry: NavBackStackEntry, task: Task): Model? {&#10;  var modelName = entry.arguments?.getString(&quot;modelName&quot;) ?: &quot;&quot;&#10;  if (modelName.isEmpty()) {&#10;    modelName = task.models[0].name&#10;  }&#10;  val model = getModelByName(modelName)&#10;  return model&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.navigation&#10;import android.util.Log&#10;import androidx.compose.animation.AnimatedContentTransitionScope&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.EnterTransition&#10;import androidx.compose.animation.ExitTransition&#10;import androidx.compose.animation.core.EaseOutExpo&#10;import androidx.compose.animation.core.FiniteAnimationSpec&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.zIndex&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import androidx.navigation.NavBackStackEntry&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navArgument&#10;import com.google.ai.edge.gallery.data.Model&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_AUDIO&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_IMAGE&#10;import com.google.ai.edge.gallery.data.TASK_LLM_CHAT&#10;import com.google.ai.edge.gallery.data.TASK_LLM_PROMPT_LAB&#10;import com.google.ai.edge.gallery.data.Task&#10;import com.google.ai.edge.gallery.data.TaskType&#10;import com.google.ai.edge.gallery.data.getModelByName&#10;import com.google.ai.edge.gallery.AuthViewModel&#10;import com.google.ai.edge.gallery.ui.auth.SignInScreen&#10;import com.google.ai.edge.gallery.SignUpScreen&#10;import androidx.compose.ui.platform.LocalContext&#10;import android.content.Intent&#10;import com.google.ai.edge.gallery.SignInActivity&#10;import com.google.ai.edge.gallery.ui.home.HomeScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatViewModel&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnDestination&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnScreen&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnViewModel&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManager&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManagerViewModel&#10;import com.google.ai.edge.gallery.ui.geofence.GeofenceManagementDestination&#10;import com.google.ai.edge.gallery.ui.geofence.GeofenceManagementScreen&#10;import com.google.ai.edge.gallery.ui.bridge.MessageBridgeDestination&#10;import com.google.ai.edge.gallery.ui.bridge.MessageBridgeScreen&#10;&#10;// Auth screen routes&#10;object SignInDestination {&#10;  const val route = &quot;sign_in&quot;&#10;}&#10;&#10;object SignUpDestination {&#10;  const val route = &quot;sign_up&quot;&#10;}&#10;&#10;private const val TAG = &quot;AGGalleryNavGraph&quot;&#10;private const val ROUTE_PLACEHOLDER = &quot;placeholder&quot;&#10;private const val ENTER_ANIMATION_DURATION_MS = 500&#10;private val ENTER_ANIMATION_EASING = EaseOutExpo&#10;private const val ENTER_ANIMATION_DELAY_MS = 100&#10;&#10;private const val EXIT_ANIMATION_DURATION_MS = 500&#10;private val EXIT_ANIMATION_EASING = EaseOutExpo&#10;&#10;private fun enterTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(&#10;    ENTER_ANIMATION_DURATION_MS,&#10;    easing = ENTER_ANIMATION_EASING,&#10;    delayMillis = ENTER_ANIMATION_DELAY_MS,&#10;  )&#10;}&#10;&#10;private fun exitTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(EXIT_ANIMATION_DURATION_MS, easing = EXIT_ANIMATION_EASING)&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideEnter(): EnterTransition {&#10;  return slideIntoContainer(&#10;    animationSpec = enterTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Left,&#10;  )&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideExit(): ExitTransition {&#10;  return slideOutOfContainer(&#10;    animationSpec = exitTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Right,&#10;  )&#10;}&#10;&#10;/** Navigation routes. */&#10;@Composable&#10;fun GalleryNavHost(&#10;  navController: NavHostController,&#10;  modifier: Modifier = Modifier,&#10;  modelManagerViewModel: ModelManagerViewModel = hiltViewModel(),&#10;) {&#10;  val lifecycleOwner = LocalLifecycleOwner.current&#10;  var showModelManager by remember { mutableStateOf(false) }&#10;  var pickedTask by remember { mutableStateOf&lt;Task?&gt;(null) }&#10;&#10;  // Track whether app is in foreground.&#10;  DisposableEffect(lifecycleOwner) {&#10;    val observer = LifecycleEventObserver { _, event -&gt;&#10;      when (event) {&#10;        Lifecycle.Event.ON_START,&#10;        Lifecycle.Event.ON_RESUME -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = true)&#10;        }&#10;        Lifecycle.Event.ON_STOP,&#10;        Lifecycle.Event.ON_PAUSE -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = false)&#10;        }&#10;        else -&gt; {&#10;          /* Do nothing for other events */&#10;        }&#10;      }&#10;    }&#10;&#10;    lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;    onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }&#10;  }&#10;&#10;  HomeScreen(&#10;    modelManagerViewModel = modelManagerViewModel,&#10;    navigateToTaskScreen = { task -&gt;&#10;      pickedTask = task&#10;      showModelManager = true&#10;    },&#10;    navigateToGeofenceManagement = {&#10;      navController.navigate(GeofenceManagementDestination.route)&#10;    },&#10;    navigateToMessageBridge = {&#10;      navController.navigate(MessageBridgeDestination.route)&#10;    }&#10;  )&#10;&#10;  // Model manager.&#10;  AnimatedVisibility(&#10;    visible = showModelManager,&#10;    enter = slideInHorizontally(initialOffsetX = { it }),&#10;    exit = slideOutHorizontally(targetOffsetX = { it }),&#10;  ) {&#10;    val curPickedTask = pickedTask&#10;    if (curPickedTask != null) {&#10;      ModelManager(&#10;        viewModel = modelManagerViewModel,&#10;        task = curPickedTask,&#10;        onModelClicked = { model -&gt;&#10;          navigateToTaskScreen(&#10;            navController = navController,&#10;            taskType = curPickedTask.type,&#10;            model = model,&#10;          )&#10;        },&#10;        navigateUp = { showModelManager = false },&#10;      )&#10;    }&#10;  }&#10;&#10;  NavHost(&#10;    navController = navController,&#10;    // Default to open home screen.&#10;    startDestination = ROUTE_PLACEHOLDER,&#10;    enterTransition = { EnterTransition.None },&#10;    exitTransition = { ExitTransition.None },&#10;    modifier = modifier.zIndex(1f),&#10;  ) {&#10;    // Placeholder root screen&#10;    composable(route = ROUTE_PLACEHOLDER) { Text(&quot;&quot;) }&#10;&#10;    // Auth screens&#10;    composable(route = SignInDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      val context = LocalContext.current&#10;      SignInScreen(&#10;        onGoogleSignInClick = {&#10;            // Launch SignInActivity to handle Google sign-in flow and Firebase auth&#10;            context.startActivity(Intent(context, SignInActivity::class.java))&#10;        },&#10;        onEmailSignInClick = { email, password -&gt;&#10;            authViewModel.signInWithEmailAndPassword(email, password)&#10;        },&#10;        onSignUpClick = {&#10;            navController.navigate(SignUpDestination.route)&#10;        }&#10;      )&#10;    }&#10;&#10;    composable(route = SignUpDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      SignUpScreen(&#10;        navController = navController,&#10;        authViewModel = authViewModel&#10;      )&#10;    }&#10;&#10;    // LLM chat demos.&#10;    composable(&#10;      route = &quot;${LlmChatDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmChatViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_CHAT)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmChatScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // LLM single turn.&#10;    composable(&#10;      route = &quot;${LlmSingleTurnDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmSingleTurnViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_PROMPT_LAB)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmSingleTurnScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask image.&#10;    composable(&#10;      route = &quot;${LlmAskImageDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskImageViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_IMAGE)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskImageScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask audio.&#10;    composable(&#10;      route = &quot;${LlmAskAudioDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskAudioViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_AUDIO)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskAudioScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Geofence management.&#10;    composable(&#10;      route = GeofenceManagementDestination.route,&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) {&#10;      GeofenceManagementScreen(&#10;        navigateUp = { navController.navigateUp() },&#10;      )&#10;    }&#10;&#10;    // Message bridge.&#10;    composable(&#10;      route = MessageBridgeDestination.route,&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) {&#10;      MessageBridgeScreen(&#10;        navigateUp = { navController.navigateUp() },&#10;      )&#10;    }&#10;  }&#10;&#10;  // Handle incoming intents for deep links&#10;  val intent = androidx.activity.compose.LocalActivity.current?.intent&#10;  val data = intent?.data&#10;  if (data != null) {&#10;    intent.data = null&#10;    Log.d(TAG, &quot;navigation link clicked: $data&quot;)&#10;    if (data.toString().startsWith(&quot;com.google.ai.edge.gallery://model/&quot;)) {&#10;      val modelName = data.pathSegments.last()&#10;      getModelByName(modelName)?.let { model -&gt;&#10;        // TODO(jingjin): need to show a list of possible tasks for this model.&#10;        navigateToTaskScreen(&#10;          navController = navController,&#10;          taskType = TaskType.LLM_CHAT,&#10;          model = model,&#10;        )&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;fun navigateToTaskScreen(&#10;  navController: NavHostController,&#10;  taskType: TaskType,&#10;  model: Model? = null,&#10;) {&#10;  val modelName = model?.name ?: &quot;&quot;&#10;  when (taskType) {&#10;    TaskType.LLM_CHAT -&gt; navController.navigate(&quot;${LlmChatDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_IMAGE -&gt; navController.navigate(&quot;${LlmAskImageDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_AUDIO -&gt; navController.navigate(&quot;${LlmAskAudioDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_PROMPT_LAB -&gt;&#10;      navController.navigate(&quot;${LlmSingleTurnDestination.route}/${modelName}&quot;)&#10;    TaskType.TEST_TASK_1 -&gt; {}&#10;    TaskType.TEST_TASK_2 -&gt; {}&#10;  }&#10;}&#10;&#10;fun getModelFromNavigationParam(entry: NavBackStackEntry, task: Task): Model? {&#10;  var modelName = entry.arguments?.getString(&quot;modelName&quot;) ?: &quot;&quot;&#10;  if (modelName.isEmpty()) {&#10;    modelName = task.models[0].name&#10;  }&#10;  val model = getModelByName(modelName)&#10;  return model&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/settings.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/settings.gradle.kts" />
              <option name="originalContent" value="&#10;&#10;pluginManagement {&#10;  repositories {&#10;    google {&#10;      content {&#10;        includeGroupByRegex(&quot;com\\.android.*&quot;)&#10;        includeGroupByRegex(&quot;com\\.google.*&quot;)&#10;        includeGroupByRegex(&quot;androidx.*&quot;)&#10;      }&#10;    }&#10;    mavenCentral()&#10;    gradlePluginPortal()&#10;  }&#10;}&#10;&#10;dependencyResolutionManagement {&#10;  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)&#10;  repositories {&#10;    //        mavenLocal()&#10;    google()&#10;    mavenCentral()&#10;    maven(&quot;https://jitpack.io&quot;)&#10;  }&#10;}&#10;&#10;rootProject.name = &quot;AI Chat Bot&quot;&#10;&#10;include(&quot;:app&quot;)&#10;" />
              <option name="updatedContent" value="pluginManagement {&#13;&#10;  repositories {&#13;&#10;    google {&#13;&#10;      content {&#13;&#10;        includeGroupByRegex(&quot;com\\.android.*&quot;)&#13;&#10;        includeGroupByRegex(&quot;com\\.google.*&quot;)&#13;&#10;        includeGroupByRegex(&quot;androidx.*&quot;)&#13;&#10;      }&#13;&#10;    }&#13;&#10;    mavenCentral()&#13;&#10;    gradlePluginPortal()&#13;&#10;    maven { url = uri(&quot;https://jitpack.io&quot;) }&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;dependencyResolutionManagement {&#13;&#10;  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)&#13;&#10;  repositories {&#13;&#10;    //        mavenLocal()&#13;&#10;    google()&#13;&#10;    mavenCentral()&#13;&#10;    maven { url = uri(&quot;https://jitpack.io&quot;) }&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;rootProject.name = &quot;AI Chat Bot&quot;&#13;&#10;&#13;&#10;include(&quot;:app&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>