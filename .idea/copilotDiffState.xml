<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/AuthViewModel.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.auth.FirebaseAuthInvalidCredentialsException&#10;import com.google.firebase.auth.FirebaseAuthInvalidUserException&#10;import com.google.firebase.auth.FirebaseAuthUserCollisionException&#10;import com.google.firebase.auth.FirebaseAuthWeakPasswordException&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val auth: FirebaseAuth&#10;) : ViewModel() {&#10;&#10;    // State holders for authentication operations&#10;    private val _signInState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val signInState: StateFlow&lt;AuthState&gt; = _signInState&#10;&#10;    private val _signUpState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val signUpState: StateFlow&lt;AuthState&gt; = _signUpState&#10;&#10;    /**&#10;     * Creates a new user with the given email and password&#10;     *&#10;     * @param email User's email address&#10;     * @param password User's password&#10;     */&#10;    fun createUserWithEmailAndPassword(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _signUpState.value = AuthState.Loading&#10;&#10;                // Validate inputs&#10;                if (email.isBlank() || password.isBlank()) {&#10;                    _signUpState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Attempt to create user&#10;                auth.createUserWithEmailAndPassword(email, password).await()&#10;&#10;                _signUpState.value = AuthState.Success(&quot;Account created successfully&quot;)&#10;            } catch (e: Exception) {&#10;                val errorMessage = when (e) {&#10;                    is FirebaseAuthWeakPasswordException -&gt; &quot;Password is too weak.&quot;&#10;                    is FirebaseAuthInvalidCredentialsException -&gt; &quot;Invalid email format.&quot;&#10;                    is FirebaseAuthUserCollisionException -&gt; &quot;This email is already in use.&quot;&#10;                    else -&gt; &quot;Sign up failed: ${e.message}&quot;&#10;                }&#10;                _signUpState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Signs in a user with the given email and password&#10;     *&#10;     * @param email User's email address&#10;     * @param password User's password&#10;     */&#10;    fun signInWithEmailAndPassword(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _signInState.value = AuthState.Loading&#10;&#10;                // Validate inputs&#10;                if (email.isBlank() || password.isBlank()) {&#10;                    _signInState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Attempt to sign in&#10;                auth.signInWithEmailAndPassword(email, password).await()&#10;&#10;                _signInState.value = AuthState.Success(&quot;Signed in successfully&quot;)&#10;            } catch (e: Exception) {&#10;                val errorMessage = when (e) {&#10;                    is FirebaseAuthInvalidUserException -&gt; &quot;User does not exist.&quot;&#10;                    is FirebaseAuthInvalidCredentialsException -&gt; &quot;Invalid email or password.&quot;&#10;                    else -&gt; &quot;Sign in failed: ${e.message}&quot;&#10;                }&#10;                _signInState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Signs in a user with Google&#10;     * This is a stub method for now, as the actual implementation would require more setup with Firebase&#10;     */&#10;    fun signInWithGoogle() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _signInState.value = AuthState.Loading&#10;                &#10;                // In a real implementation, you would:&#10;                // 1. Start the Google Sign-In intent&#10;                // 2. Handle the result in your activity&#10;                // 3. Get the Google credentials&#10;                // 4. Use those to sign in with Firebase&#10;                &#10;                // For now, we'll just show a message&#10;                _signInState.value = AuthState.Info(&quot;Google Sign-In would start here&quot;)&#10;                &#10;                // In real implementation, you would authenticate with Firebase like:&#10;                // val credential = GoogleAuthProvider.getCredential(idToken, null)&#10;                // auth.signInWithCredential(credential).await()&#10;            } catch (e: Exception) {&#10;                _signInState.value = AuthState.Error(&quot;Google sign in failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resets the sign-in state to idle&#10;     */&#10;    fun resetSignInState() {&#10;        _signInState.value = AuthState.Idle&#10;    }&#10;&#10;    /**&#10;     * Resets the sign-up state to idle&#10;     */&#10;    fun resetSignUpState() {&#10;        _signUpState.value = AuthState.Idle&#10;    }&#10;}&#10;&#10;/**&#10; * Represents the various states of an authentication operation&#10; */&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val message: String) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;    data class Info(val message: String) : AuthState()&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.auth.FirebaseAuthInvalidCredentialsException&#10;import com.google.firebase.auth.FirebaseAuthInvalidUserException&#10;import com.google.firebase.auth.FirebaseAuthUserCollisionException&#10;import com.google.firebase.auth.FirebaseAuthWeakPasswordException&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val auth: FirebaseAuth&#10;) : ViewModel() {&#10;&#10;    // State holders for authentication operations&#10;    private val _signInState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val signInState: StateFlow&lt;AuthState&gt; = _signInState&#10;&#10;    private val _signUpState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val signUpState: StateFlow&lt;AuthState&gt; = _signUpState&#10;&#10;    /**&#10;     * Creates a new user with the given email and password&#10;     *&#10;     * @param email User's email address&#10;     * @param password User's password&#10;     */&#10;    fun createUserWithEmailAndPassword(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _signUpState.value = AuthState.Loading&#10;&#10;                // Validate inputs&#10;                if (email.isBlank() || password.isBlank()) {&#10;                    _signUpState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Attempt to create user&#10;                auth.createUserWithEmailAndPassword(email, password).await()&#10;&#10;                _signUpState.value = AuthState.Success(&quot;Account created successfully&quot;)&#10;            } catch (e: Exception) {&#10;                val errorMessage = when (e) {&#10;                    is FirebaseAuthWeakPasswordException -&gt; &quot;Password is too weak.&quot;&#10;                    is FirebaseAuthInvalidCredentialsException -&gt; &quot;Invalid email format.&quot;&#10;                    is FirebaseAuthUserCollisionException -&gt; &quot;This email is already in use.&quot;&#10;                    else -&gt; &quot;Sign up failed: ${e.message}&quot;&#10;                }&#10;                _signUpState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Signs in a user with the given email and password&#10;     *&#10;     * @param email User's email address&#10;     * @param password User's password&#10;     */&#10;    fun signInWithEmailAndPassword(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _signInState.value = AuthState.Loading&#10;&#10;                // Validate inputs&#10;                if (email.isBlank() || password.isBlank()) {&#10;                    _signInState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#10;                    return@launch&#10;                }&#10;&#10;                // Attempt to sign in&#10;                auth.signInWithEmailAndPassword(email, password).await()&#10;&#10;                _signInState.value = AuthState.Success(&quot;Signed in successfully&quot;)&#10;            } catch (e: Exception) {&#10;                val errorMessage = when (e) {&#10;                    is FirebaseAuthInvalidUserException -&gt; &quot;User does not exist.&quot;&#10;                    is FirebaseAuthInvalidCredentialsException -&gt; &quot;Invalid email or password.&quot;&#10;                    else -&gt; &quot;Sign in failed: ${e.message}&quot;&#10;                }&#10;                _signInState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Signs in a user with Google&#10;     * This method initiates the Google Sign-In process&#10;     */&#10;    fun signInWithGoogle() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _signInState.value = AuthState.Loading&#10;                &#10;                // Note: The actual Google Sign-In process will be initiated by the activity/fragment&#10;                // This method primarily updates state and prepares for authentication&#10;                &#10;                // The actual authentication with Firebase using the Google credentials&#10;                // will happen in the activity after getting the result from the Google Sign-In intent&#10;                &#10;                _signInState.value = AuthState.Info(&quot;Starting Google Sign-In&quot;)&#10;            } catch (e: Exception) {&#10;                _signInState.value = AuthState.Error(&quot;Google sign in failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Resets the sign-in state to idle&#10;     */&#10;    fun resetSignInState() {&#10;        _signInState.value = AuthState.Idle&#10;    }&#10;&#10;    /**&#10;     * Resets the sign-up state to idle&#10;     */&#10;    fun resetSignUpState() {&#10;        _signUpState.value = AuthState.Idle&#10;    }&#10;}&#10;&#10;/**&#10; * Represents the various states of an authentication operation&#10; */&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val message: String) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;    data class Info(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/SignUpScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/SignUpScreen.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavHostController&#10;import com.google.ai.edge.gallery.ui.auth.SignInDestination&#10;&#10;@Composable&#10;fun SignUpScreen(&#10;    navController: NavHostController,&#10;    authViewModel: AuthViewModel&#10;) {&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var confirmPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordsMatch by remember { mutableStateOf(true) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(32.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        // Title&#10;        Text(&#10;            text = &quot;Create Account&quot;,&#10;            fontSize = 28.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color(0xFF212121),&#10;            modifier = Modifier.padding(bottom = 32.dp)&#10;        )&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.text.style.TextDecoration&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavHostController&#10;import com.google.ai.edge.gallery.ui.auth.SignInDestination&#10;&#10;@Composable&#10;fun SignUpScreen(&#10;    navController: NavHostController,&#10;    authViewModel: AuthViewModel&#10;) {&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var confirmPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordsMatch by remember { mutableStateOf(true) }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(32.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        verticalArrangement = Arrangement.Center&#10;    ) {&#10;        // Title&#10;        Text(&#10;            text = &quot;Create Account&quot;,&#10;            fontSize = 28.sp,&#10;            fontWeight = FontWeight.Bold,&#10;            color = Color(0xFF212121),&#10;            modifier = Modifier.padding(bottom = 32.dp)&#10;        )&#10;&#10;        // Email Field&#10;        OutlinedTextField(&#10;            value = email,&#10;            onValueChange = { email = it },&#10;            label = { Text(&quot;Email Address&quot;) },&#10;            singleLine = true,&#10;            keyboardOptions = KeyboardOptions(&#10;                keyboardType = KeyboardType.Email,&#10;                imeAction = ImeAction.Next&#10;            ),&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Password Field&#10;        OutlinedTextField(&#10;            value = password,&#10;            onValueChange = {&#10;                password = it&#10;                passwordsMatch = it == confirmPassword || confirmPassword.isEmpty()&#10;            },&#10;            label = { Text(&quot;Password&quot;) },&#10;            singleLine = true,&#10;            visualTransformation = PasswordVisualTransformation(),&#10;            keyboardOptions = KeyboardOptions(&#10;                keyboardType = KeyboardType.Password,&#10;                imeAction = ImeAction.Next&#10;            ),&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Confirm Password Field&#10;        OutlinedTextField(&#10;            value = confirmPassword,&#10;            onValueChange = {&#10;                confirmPassword = it&#10;                passwordsMatch = password == it || it.isEmpty()&#10;            },&#10;            label = { Text(&quot;Confirm Password&quot;) },&#10;            singleLine = true,&#10;            visualTransformation = PasswordVisualTransformation(),&#10;            keyboardOptions = KeyboardOptions(&#10;                keyboardType = KeyboardType.Password,&#10;                imeAction = ImeAction.Done&#10;            ),&#10;            isError = !passwordsMatch,&#10;            supportingText = {&#10;                if (!passwordsMatch) {&#10;                    Text(&#10;                        text = &quot;Passwords don't match&quot;,&#10;                        color = MaterialTheme.colorScheme.error&#10;                    )&#10;                }&#10;            },&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 24.dp)&#10;        )&#10;&#10;        // Sign Up Button&#10;        Button(&#10;            onClick = {&#10;                if (passwordsMatch &amp;&amp; password.isNotEmpty() &amp;&amp; email.isNotEmpty()) {&#10;                    // Call the ViewModel function directly&#10;                    authViewModel.createUserWithEmailAndPassword(email, password)&#10;                }&#10;            },&#10;            enabled = passwordsMatch &amp;&amp; password.isNotEmpty() &amp;&amp; confirmPassword.isNotEmpty() &amp;&amp; email.isNotEmpty(),&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .height(48.dp)&#10;                .padding(bottom = 16.dp)&#10;        ) {&#10;            Text(&quot;Sign Up&quot;)&#10;        }&#10;&#10;        // Sign In Text&#10;        Text(&#10;            text = &quot;Already have an account? Sign In&quot;,&#10;            color = Color(0xFF1976D2),&#10;            textDecoration = TextDecoration.Underline,&#10;            modifier = Modifier&#10;                .padding(top = 16.dp)&#10;                .clickable {&#10;                    // Use the NavController to navigate to the sign in screen&#10;                    navController.navigate(SignInDestination.route) {&#10;                        popUpTo(navController.graph.startDestinationId)&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/navigation/GalleryNavGraph.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Android/src/app/src/main/java/com/google/ai/edge/gallery/ui/navigation/GalleryNavGraph.kt" />
              <option name="originalContent" value="package com.google.ai.edge.gallery.ui.navigation&#10;import android.util.Log&#10;import androidx.compose.animation.AnimatedContentTransitionScope&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.EnterTransition&#10;import androidx.compose.animation.ExitTransition&#10;import androidx.compose.animation.core.EaseOutExpo&#10;import androidx.compose.animation.core.FiniteAnimationSpec&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.zIndex&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import androidx.navigation.NavBackStackEntry&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navArgument&#10;import com.google.ai.edge.gallery.data.Model&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_AUDIO&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_IMAGE&#10;import com.google.ai.edge.gallery.data.TASK_LLM_CHAT&#10;import com.google.ai.edge.gallery.data.TASK_LLM_PROMPT_LAB&#10;import com.google.ai.edge.gallery.data.Task&#10;import com.google.ai.edge.gallery.data.TaskType&#10;import com.google.ai.edge.gallery.data.getModelByName&#10;import com.google.ai.edge.gallery.ui.auth.AuthViewModel&#10;import com.google.ai.edge.gallery.ui.auth.SignInDestination&#10;import com.google.ai.edge.gallery.ui.auth.SignInScreen&#10;import com.google.ai.edge.gallery.ui.auth.SignUpDestination&#10;import com.google.ai.edge.gallery.ui.auth.SignUpScreen&#10;import com.google.ai.edge.gallery.ui.home.HomeScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatViewModel&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnDestination&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnScreen&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnViewModel&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManager&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManagerViewModel&#10;&#10;// Auth screen routes&#10;object SignInDestination {&#10;  const val route = &quot;sign_in&quot;&#10;}&#10;&#10;object SignUpDestination {&#10;  const val route = &quot;sign_up&quot;&#10;}&#10;&#10;private const val TAG = &quot;AGGalleryNavGraph&quot;&#10;private const val ROUTE_PLACEHOLDER = &quot;placeholder&quot;&#10;private const val ENTER_ANIMATION_DURATION_MS = 500&#10;private val ENTER_ANIMATION_EASING = EaseOutExpo&#10;private const val ENTER_ANIMATION_DELAY_MS = 100&#10;&#10;private const val EXIT_ANIMATION_DURATION_MS = 500&#10;private val EXIT_ANIMATION_EASING = EaseOutExpo&#10;&#10;private fun enterTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(&#10;    ENTER_ANIMATION_DURATION_MS,&#10;    easing = ENTER_ANIMATION_EASING,&#10;    delayMillis = ENTER_ANIMATION_DELAY_MS,&#10;  )&#10;}&#10;&#10;private fun exitTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(EXIT_ANIMATION_DURATION_MS, easing = EXIT_ANIMATION_EASING)&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideEnter(): EnterTransition {&#10;  return slideIntoContainer(&#10;    animationSpec = enterTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Left,&#10;  )&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideExit(): ExitTransition {&#10;  return slideOutOfContainer(&#10;    animationSpec = exitTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Right,&#10;  )&#10;}&#10;&#10;/** Navigation routes. */&#10;@Composable&#10;fun GalleryNavHost(&#10;  navController: NavHostController,&#10;  modifier: Modifier = Modifier,&#10;  modelManagerViewModel: ModelManagerViewModel = hiltViewModel(),&#10;) {&#10;  val lifecycleOwner = LocalLifecycleOwner.current&#10;  var showModelManager by remember { mutableStateOf(false) }&#10;  var pickedTask by remember { mutableStateOf&lt;Task?&gt;(null) }&#10;&#10;  // Track whether app is in foreground.&#10;  DisposableEffect(lifecycleOwner) {&#10;    val observer = LifecycleEventObserver { _, event -&gt;&#10;      when (event) {&#10;        Lifecycle.Event.ON_START,&#10;        Lifecycle.Event.ON_RESUME -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = true)&#10;        }&#10;        Lifecycle.Event.ON_STOP,&#10;        Lifecycle.Event.ON_PAUSE -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = false)&#10;        }&#10;        else -&gt; {&#10;          /* Do nothing for other events */&#10;        }&#10;      }&#10;    }&#10;&#10;    lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;    onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }&#10;  }&#10;&#10;  HomeScreen(&#10;    modelManagerViewModel = modelManagerViewModel,&#10;    navigateToTaskScreen = { task -&gt;&#10;      pickedTask = task&#10;      showModelManager = true&#10;    },&#10;  )&#10;&#10;  // Model manager.&#10;  AnimatedVisibility(&#10;    visible = showModelManager,&#10;    enter = slideInHorizontally(initialOffsetX = { it }),&#10;    exit = slideOutHorizontally(targetOffsetX = { it }),&#10;  ) {&#10;    val curPickedTask = pickedTask&#10;    if (curPickedTask != null) {&#10;      ModelManager(&#10;        viewModel = modelManagerViewModel,&#10;        task = curPickedTask,&#10;        onModelClicked = { model -&gt;&#10;          navigateToTaskScreen(&#10;            navController = navController,&#10;            taskType = curPickedTask.type,&#10;            model = model,&#10;          )&#10;        },&#10;        navigateUp = { showModelManager = false },&#10;      )&#10;    }&#10;  }&#10;&#10;  NavHost(&#10;    navController = navController,&#10;    // Default to open home screen.&#10;    startDestination = ROUTE_PLACEHOLDER,&#10;    enterTransition = { EnterTransition.None },&#10;    exitTransition = { ExitTransition.None },&#10;    modifier = modifier.zIndex(1f),&#10;  ) {&#10;    // Placeholder root screen&#10;    composable(route = ROUTE_PLACEHOLDER) { Text(&quot;&quot;) }&#10;&#10;    // Auth screens&#10;    composable(route = SignInDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      SignInScreen(&#10;        onGoogleSignInClick = {&#10;            // Call the Google sign-in function from the ViewModel&#10;            authViewModel.signInWithGoogle()&#10;        },&#10;        onEmailSignInClick = { email, password -&gt;&#10;            authViewModel.signInWithEmailAndPassword(email, password)&#10;        },&#10;        onSignUpClick = {&#10;            navController.navigate(SignUpDestination.route)&#10;        }&#10;      )&#10;    }&#10;&#10;    composable(route = SignUpDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      SignUpScreen(&#10;        navController = navController,&#10;        authViewModel = authViewModel&#10;      )&#10;    }&#10;&#10;    // LLM chat demos.&#10;    composable(&#10;      route = &quot;${LlmChatDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmChatViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_CHAT)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmChatScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // LLM single turn.&#10;    composable(&#10;      route = &quot;${LlmSingleTurnDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmSingleTurnViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_PROMPT_LAB)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmSingleTurnScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask image.&#10;    composable(&#10;      route = &quot;${LlmAskImageDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskImageViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_IMAGE)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskImageScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask audio.&#10;    composable(&#10;      route = &quot;${LlmAskAudioDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskAudioViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_AUDIO)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskAudioScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;  }&#10;&#10;  // Handle incoming intents for deep links&#10;  val intent = androidx.activity.compose.LocalActivity.current?.intent&#10;  val data = intent?.data&#10;  if (data != null) {&#10;    intent.data = null&#10;    Log.d(TAG, &quot;navigation link clicked: $data&quot;)&#10;    if (data.toString().startsWith(&quot;com.google.ai.edge.gallery://model/&quot;)) {&#10;      val modelName = data.pathSegments.last()&#10;      getModelByName(modelName)?.let { model -&gt;&#10;        // TODO(jingjin): need to show a list of possible tasks for this model.&#10;        navigateToTaskScreen(&#10;          navController = navController,&#10;          taskType = TaskType.LLM_CHAT,&#10;          model = model,&#10;        )&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;fun navigateToTaskScreen(&#10;  navController: NavHostController,&#10;  taskType: TaskType,&#10;  model: Model? = null,&#10;) {&#10;  val modelName = model?.name ?: &quot;&quot;&#10;  when (taskType) {&#10;    TaskType.LLM_CHAT -&gt; navController.navigate(&quot;${LlmChatDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_IMAGE -&gt; navController.navigate(&quot;${LlmAskImageDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_AUDIO -&gt; navController.navigate(&quot;${LlmAskAudioDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_PROMPT_LAB -&gt;&#10;      navController.navigate(&quot;${LlmSingleTurnDestination.route}/${modelName}&quot;)&#10;    TaskType.TEST_TASK_1 -&gt; {}&#10;    TaskType.TEST_TASK_2 -&gt; {}&#10;  }&#10;}&#10;&#10;fun getModelFromNavigationParam(entry: NavBackStackEntry, task: Task): Model? {&#10;  var modelName = entry.arguments?.getString(&quot;modelName&quot;) ?: &quot;&quot;&#10;  if (modelName.isEmpty()) {&#10;    modelName = task.models[0].name&#10;  }&#10;  val model = getModelByName(modelName)&#10;  return model&#10;}&#10;" />
              <option name="updatedContent" value="package com.google.ai.edge.gallery.ui.navigation&#10;&#10;import android.util.Log&#10;import androidx.compose.animation.AnimatedContentTransitionScope&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.EnterTransition&#10;import androidx.compose.animation.ExitTransition&#10;import androidx.compose.animation.core.EaseOutExpo&#10;import androidx.compose.animation.core.FiniteAnimationSpec&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.animation.slideInHorizontally&#10;import androidx.compose.animation.slideOutHorizontally&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.zIndex&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import androidx.navigation.NavBackStackEntry&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.navArgument&#10;import com.google.ai.edge.gallery.AuthViewModel&#10;import com.google.ai.edge.gallery.SignUpScreen&#10;import com.google.ai.edge.gallery.data.Model&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_AUDIO&#10;import com.google.ai.edge.gallery.data.TASK_LLM_ASK_IMAGE&#10;import com.google.ai.edge.gallery.data.TASK_LLM_CHAT&#10;import com.google.ai.edge.gallery.data.TASK_LLM_PROMPT_LAB&#10;import com.google.ai.edge.gallery.data.Task&#10;import com.google.ai.edge.gallery.data.TaskType&#10;import com.google.ai.edge.gallery.data.getModelByName&#10;import com.google.ai.edge.gallery.ui.auth.SignInDestination&#10;import com.google.ai.edge.gallery.ui.auth.SignInScreen&#10;import com.google.ai.edge.gallery.ui.home.HomeScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskAudioViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmAskImageViewModel&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatDestination&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatScreen&#10;import com.google.ai.edge.gallery.ui.llmchat.LlmChatViewModel&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnDestination&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnScreen&#10;import com.google.ai.edge.gallery.ui.llmsingleturn.LlmSingleTurnViewModel&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManager&#10;import com.google.ai.edge.gallery.ui.modelmanager.ModelManagerViewModel&#10;&#10;// Auth screen routes&#10;object SignInDestination {&#10;  const val route = &quot;sign_in&quot;&#10;}&#10;&#10;object SignUpDestination {&#10;  const val route = &quot;sign_up&quot;&#10;}&#10;&#10;private const val TAG = &quot;AGGalleryNavGraph&quot;&#10;private const val ROUTE_PLACEHOLDER = &quot;placeholder&quot;&#10;private const val ENTER_ANIMATION_DURATION_MS = 500&#10;private val ENTER_ANIMATION_EASING = EaseOutExpo&#10;private const val ENTER_ANIMATION_DELAY_MS = 100&#10;&#10;private const val EXIT_ANIMATION_DURATION_MS = 500&#10;private val EXIT_ANIMATION_EASING = EaseOutExpo&#10;&#10;private fun enterTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(&#10;    ENTER_ANIMATION_DURATION_MS,&#10;    easing = ENTER_ANIMATION_EASING,&#10;    delayMillis = ENTER_ANIMATION_DELAY_MS,&#10;  )&#10;}&#10;&#10;private fun exitTween(): FiniteAnimationSpec&lt;IntOffset&gt; {&#10;  return tween(EXIT_ANIMATION_DURATION_MS, easing = EXIT_ANIMATION_EASING)&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideEnter(): EnterTransition {&#10;  return slideIntoContainer(&#10;    animationSpec = enterTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Left,&#10;  )&#10;}&#10;&#10;private fun AnimatedContentTransitionScope&lt;*&gt;.slideExit(): ExitTransition {&#10;  return slideOutOfContainer(&#10;    animationSpec = exitTween(),&#10;    towards = AnimatedContentTransitionScope.SlideDirection.Right,&#10;  )&#10;}&#10;&#10;/** Navigation routes. */&#10;@Composable&#10;fun GalleryNavHost(&#10;  navController: NavHostController,&#10;  modifier: Modifier = Modifier,&#10;  modelManagerViewModel: ModelManagerViewModel = hiltViewModel(),&#10;) {&#10;  val lifecycleOwner = LocalLifecycleOwner.current&#10;  var showModelManager by remember { mutableStateOf(false) }&#10;  var pickedTask by remember { mutableStateOf&lt;Task?&gt;(null) }&#10;&#10;  // Track whether app is in foreground.&#10;  DisposableEffect(lifecycleOwner) {&#10;    val observer = LifecycleEventObserver { _, event -&gt;&#10;      when (event) {&#10;        Lifecycle.Event.ON_START,&#10;        Lifecycle.Event.ON_RESUME -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = true)&#10;        }&#10;        Lifecycle.Event.ON_STOP,&#10;        Lifecycle.Event.ON_PAUSE -&gt; {&#10;          modelManagerViewModel.setAppInForeground(foreground = false)&#10;        }&#10;        else -&gt; {&#10;          /* Do nothing for other events */&#10;        }&#10;      }&#10;    }&#10;&#10;    lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;    onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }&#10;  }&#10;&#10;  HomeScreen(&#10;    modelManagerViewModel = modelManagerViewModel,&#10;    navigateToTaskScreen = { task -&gt;&#10;      pickedTask = task&#10;      showModelManager = true&#10;    },&#10;  )&#10;&#10;  // Model manager.&#10;  AnimatedVisibility(&#10;    visible = showModelManager,&#10;    enter = slideInHorizontally(initialOffsetX = { it }),&#10;    exit = slideOutHorizontally(targetOffsetX = { it }),&#10;  ) {&#10;    val curPickedTask = pickedTask&#10;    if (curPickedTask != null) {&#10;      ModelManager(&#10;        viewModel = modelManagerViewModel,&#10;        task = curPickedTask,&#10;        onModelClicked = { model -&gt;&#10;          navigateToTaskScreen(&#10;            navController = navController,&#10;            taskType = curPickedTask.type,&#10;            model = model,&#10;          )&#10;        },&#10;        navigateUp = { showModelManager = false },&#10;      )&#10;    }&#10;  }&#10;&#10;  NavHost(&#10;    navController = navController,&#10;    // Default to open home screen.&#10;    startDestination = ROUTE_PLACEHOLDER,&#10;    enterTransition = { EnterTransition.None },&#10;    exitTransition = { ExitTransition.None },&#10;    modifier = modifier.zIndex(1f),&#10;  ) {&#10;    // Placeholder root screen&#10;    composable(route = ROUTE_PLACEHOLDER) { Text(&quot;&quot;) }&#10;&#10;    // Auth screens&#10;    composable(route = SignInDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      SignInScreen(&#10;        onGoogleSignInClick = {&#10;            // Call the Google sign-in function from the ViewModel&#10;            authViewModel.signInWithGoogle()&#10;        },&#10;        onEmailSignInClick = { email, password -&gt;&#10;            authViewModel.signInWithEmailAndPassword(email, password)&#10;        },&#10;        onSignUpClick = {&#10;            navController.navigate(SignUpDestination.route)&#10;        }&#10;      )&#10;    }&#10;&#10;    composable(route = SignUpDestination.route) {&#10;      val authViewModel: AuthViewModel = hiltViewModel()&#10;      SignUpScreen(&#10;        navController = navController,&#10;        authViewModel = authViewModel&#10;      )&#10;    }&#10;&#10;    // LLM chat demos.&#10;    composable(&#10;      route = &quot;${LlmChatDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmChatViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_CHAT)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmChatScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // LLM single turn.&#10;    composable(&#10;      route = &quot;${LlmSingleTurnDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmSingleTurnViewModel = hiltViewModel(backStackEntry)&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_PROMPT_LAB)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmSingleTurnScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask image.&#10;    composable(&#10;      route = &quot;${LlmAskImageDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskImageViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_IMAGE)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskImageScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;&#10;    // Ask audio.&#10;    composable(&#10;      route = &quot;${LlmAskAudioDestination.route}/{modelName}&quot;,&#10;      arguments = listOf(navArgument(&quot;modelName&quot;) { type = NavType.StringType }),&#10;      enterTransition = { slideEnter() },&#10;      exitTransition = { slideExit() },&#10;    ) { backStackEntry -&gt;&#10;      val viewModel: LlmAskAudioViewModel = hiltViewModel()&#10;&#10;      getModelFromNavigationParam(backStackEntry, TASK_LLM_ASK_AUDIO)?.let { defaultModel -&gt;&#10;        modelManagerViewModel.selectModel(defaultModel)&#10;&#10;        LlmAskAudioScreen(&#10;          viewModel = viewModel,&#10;          modelManagerViewModel = modelManagerViewModel,&#10;          navigateUp = { navController.navigateUp() },&#10;        )&#10;      }&#10;    }&#10;  }&#10;&#10;  // Handle incoming intents for deep links&#10;  val intent = androidx.activity.compose.LocalActivity.current?.intent&#10;  val data = intent?.data&#10;  if (data != null) {&#10;    intent.data = null&#10;    Log.d(TAG, &quot;navigation link clicked: $data&quot;)&#10;    if (data.toString().startsWith(&quot;com.google.ai.edge.gallery://model/&quot;)) {&#10;      val modelName = data.pathSegments.last()&#10;      getModelByName(modelName)?.let { model -&gt;&#10;        // TODO(jingjin): need to show a list of possible tasks for this model.&#10;        navigateToTaskScreen(&#10;          navController = navController,&#10;          taskType = TaskType.LLM_CHAT,&#10;          model = model,&#10;        )&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;fun navigateToTaskScreen(&#10;  navController: NavHostController,&#10;  taskType: TaskType,&#10;  model: Model? = null,&#10;) {&#10;  val modelName = model?.name ?: &quot;&quot;&#10;  when (taskType) {&#10;    TaskType.LLM_CHAT -&gt; navController.navigate(&quot;${LlmChatDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_IMAGE -&gt; navController.navigate(&quot;${LlmAskImageDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_ASK_AUDIO -&gt; navController.navigate(&quot;${LlmAskAudioDestination.route}/${modelName}&quot;)&#10;    TaskType.LLM_PROMPT_LAB -&gt;&#10;      navController.navigate(&quot;${LlmSingleTurnDestination.route}/${modelName}&quot;)&#10;    TaskType.TEST_TASK_1 -&gt; {}&#10;    TaskType.TEST_TASK_2 -&gt; {}&#10;  }&#10;}&#10;&#10;fun getModelFromNavigationParam(entry: NavBackStackEntry, task: Task): Model? {&#10;  var modelName = entry.arguments?.getString(&quot;modelName&quot;) ?: &quot;&quot;&#10;  if (modelName.isEmpty()) {&#10;    modelName = task.models[0].name&#10;  }&#10;  val model = getModelByName(modelName)&#10;  return model&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>